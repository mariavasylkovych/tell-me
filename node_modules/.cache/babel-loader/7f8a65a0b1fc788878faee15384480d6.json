{"ast":null,"code":"const Fetcher = require('./fetcher.js');\n\nconst fsm = require('fs-minipass');\n\nconst cacache = require('cacache');\n\nconst {\n  promisify\n} = require('util');\n\nconst readPackageJson = require('read-package-json-fast');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst _exeBins = Symbol('_exeBins');\n\nconst {\n  resolve\n} = require('path');\n\nconst fs = require('fs');\n\nclass FileFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts); // just the fully resolved filename\n\n    this.resolved = this.spec.fetchSpec;\n  }\n\n  get types() {\n    return ['file'];\n  }\n\n  manifest() {\n    if (this.package) return Promise.resolve(this.package); // have to unpack the tarball for this.\n\n    return cacache.tmp.withTmp(this.cache, this.opts, dir => this.extract(dir).then(() => readPackageJson(dir + '/package.json')).then(mani => this.package = { ...mani,\n      _integrity: this.integrity && String(this.integrity),\n      _resolved: this.resolved,\n      _from: this.from\n    }));\n  }\n\n  [_exeBins](pkg, dest) {\n    if (!pkg.bin) return Promise.resolve();\n    return Promise.all(Object.keys(pkg.bin).map(k => new Promise(res => {\n      const script = resolve(dest, pkg.bin[k]); // Best effort.  Ignore errors here, the only result is that\n      // a bin script is not executable.  But if it's missing or\n      // something, we just leave it for a later stage to trip over\n      // when we can provide a more useful contextual error.\n\n      fs.stat(script, (er, st) => {\n        if (er) return res();\n        const mode = st.mode | 0o111;\n        if (mode === st.mode) return res();\n        fs.chmod(script, mode, res);\n      });\n    })));\n  }\n\n  extract(dest) {\n    // if we've already loaded the manifest, then the super got it.\n    // but if not, read the unpacked manifest and chmod properly.\n    return super.extract(dest).then(result => this.package ? result : readPackageJson(dest + '/package.json').then(pkg => this[_exeBins](pkg, dest)).then(() => result));\n  }\n\n  [_tarballFromResolved]() {\n    // create a read stream and return it\n    return new fsm.ReadStream(this.resolved);\n  }\n\n  packument() {\n    // simulate based on manifest\n    return this.manifest().then(mani => ({\n      name: mani.name,\n      'dist-tags': {\n        [this.defaultTag]: mani.version\n      },\n      versions: {\n        [mani.version]: { ...mani,\n          dist: {\n            tarball: `file:${this.resolved}`,\n            integrity: this.integrity && String(this.integrity)\n          }\n        }\n      }\n    }));\n  }\n\n}\n\nmodule.exports = FileFetcher;","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/pacote/lib/file.js"],"names":["Fetcher","require","fsm","cacache","promisify","readPackageJson","_tarballFromResolved","Symbol","for","_exeBins","resolve","fs","FileFetcher","constructor","spec","opts","resolved","fetchSpec","types","manifest","package","Promise","tmp","withTmp","cache","dir","extract","then","mani","_integrity","integrity","String","_resolved","_from","from","pkg","dest","bin","all","Object","keys","map","k","res","script","stat","er","st","mode","chmod","result","ReadStream","packument","name","defaultTag","version","versions","dist","tarball","module","exports"],"mappings":"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","sourcesContent":["const Fetcher = require('./fetcher.js')\nconst fsm = require('fs-minipass')\nconst cacache = require('cacache')\nconst { promisify } = require('util')\nconst readPackageJson = require('read-package-json-fast')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst _exeBins = Symbol('_exeBins')\nconst { resolve } = require('path')\nconst fs = require('fs')\n\nclass FileFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n    // just the fully resolved filename\n    this.resolved = this.spec.fetchSpec\n  }\n\n  get types () {\n    return ['file']\n  }\n\n  manifest () {\n    if (this.package)\n      return Promise.resolve(this.package)\n\n    // have to unpack the tarball for this.\n    return cacache.tmp.withTmp(this.cache, this.opts, dir =>\n      this.extract(dir)\n      .then(() => readPackageJson(dir + '/package.json'))\n      .then(mani => this.package = {\n        ...mani,\n        _integrity: this.integrity && String(this.integrity),\n        _resolved: this.resolved,\n        _from: this.from,\n      }))\n  }\n\n  [_exeBins] (pkg, dest) {\n    if (!pkg.bin)\n      return Promise.resolve()\n\n    return Promise.all(Object.keys(pkg.bin).map(k => new Promise(res => {\n      const script = resolve(dest, pkg.bin[k])\n      // Best effort.  Ignore errors here, the only result is that\n      // a bin script is not executable.  But if it's missing or\n      // something, we just leave it for a later stage to trip over\n      // when we can provide a more useful contextual error.\n      fs.stat(script, (er, st) => {\n        if (er)\n          return res()\n        const mode = st.mode | 0o111\n        if (mode === st.mode)\n          return res()\n        fs.chmod(script, mode, res)\n      })\n    })))\n  }\n\n  extract (dest) {\n    // if we've already loaded the manifest, then the super got it.\n    // but if not, read the unpacked manifest and chmod properly.\n    return super.extract(dest)\n      .then(result => this.package ? result\n        : readPackageJson(dest + '/package.json').then(pkg =>\n          this[_exeBins](pkg, dest)).then(() => result))\n  }\n\n  [_tarballFromResolved] () {\n    // create a read stream and return it\n    return new fsm.ReadStream(this.resolved)\n  }\n\n  packument () {\n    // simulate based on manifest\n    return this.manifest().then(mani => ({\n      name: mani.name,\n      'dist-tags': {\n        [this.defaultTag]: mani.version\n      },\n      versions: {\n        [mani.version]: {\n          ...mani,\n          dist: {\n            tarball: `file:${this.resolved}`,\n            integrity: this.integrity && String(this.integrity),\n          }\n        }\n      }\n    }))\n  }\n}\n\nmodule.exports = FileFetcher\n"]},"metadata":{},"sourceType":"script"}