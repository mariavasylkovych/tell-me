{"ast":null,"code":"const {\n  resolve,\n  dirname\n} = require('path');\n\nconst isWindows = require('./is-windows.js'); // the path here is relative, even though it does not need to be\n// in order to make the posix tests pass in windows\n\n\nconst nodeGypPath = resolve(__dirname, '../lib/node-gyp-bin'); // Windows typically calls its PATH environ 'Path', but this is not\n// guaranteed, nor is it guaranteed to be the only one.  Merge them\n// all together in the order they appear in the object.\n\nconst setPATH = (projectPath, env) => {\n  // not require('path').delimiter, because we fake this for testing\n  const delimiter = isWindows ? ';' : ':';\n  const PATH = Object.keys(env).filter(p => /^path$/i.test(p) && env[p]).map(p => env[p].split(delimiter)).reduce((set, p) => set.concat(p.filter(p => !set.includes(p))), []).join(delimiter);\n  const pathArr = []; // unshift the ./node_modules/.bin from every folder\n  // walk up until dirname() does nothing, at the root\n  // XXX should we specify a cwd that we don't go above?\n\n  let p = projectPath;\n  let pp;\n\n  do {\n    pathArr.push(resolve(p, 'node_modules', '.bin'));\n    pp = p;\n    p = dirname(p);\n  } while (p !== pp);\n\n  pathArr.push(nodeGypPath, PATH);\n  const pathVal = pathArr.join(delimiter); // XXX include the node-gyp-bin path somehow?  Probably better for\n  // npm or arborist or whoever to just provide that by putting it in\n  // the PATH environ, since that's preserved anyway.\n\n  for (const key of Object.keys(env)) {\n    if (/^path$/i.test(key)) env[key] = pathVal;\n  }\n\n  return env;\n};\n\nmodule.exports = setPATH;","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/@npmcli/run-script/lib/set-path.js"],"names":["resolve","dirname","require","isWindows","nodeGypPath","__dirname","setPATH","projectPath","env","delimiter","PATH","Object","keys","filter","p","test","map","split","reduce","set","concat","includes","join","pathArr","pp","push","pathVal","key","module","exports"],"mappings":"AAAA,MAAM;AAACA,EAAAA,OAAD;AAAUC,EAAAA;AAAV,IAAqBC,OAAO,CAAC,MAAD,CAAlC;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,iBAAD,CAAzB,C,CACA;AACA;;;AACA,MAAME,WAAW,GAAGJ,OAAO,CAACK,SAAD,EAAY,qBAAZ,CAA3B,C,CAEA;AACA;AACA;;AACA,MAAMC,OAAO,GAAG,CAACC,WAAD,EAAcC,GAAd,KAAsB;AACpC;AACA,QAAMC,SAAS,GAAGN,SAAS,GAAG,GAAH,GAAS,GAApC;AACA,QAAMO,IAAI,GAAGC,MAAM,CAACC,IAAP,CAAYJ,GAAZ,EAAiBK,MAAjB,CAAwBC,CAAC,IAAI,UAAUC,IAAV,CAAeD,CAAf,KAAqBN,GAAG,CAACM,CAAD,CAArD,EACVE,GADU,CACNF,CAAC,IAAIN,GAAG,CAACM,CAAD,CAAH,CAAOG,KAAP,CAAaR,SAAb,CADC,EAEVS,MAFU,CAEH,CAACC,GAAD,EAAML,CAAN,KAAYK,GAAG,CAACC,MAAJ,CAAWN,CAAC,CAACD,MAAF,CAASC,CAAC,IAAI,CAACK,GAAG,CAACE,QAAJ,CAAaP,CAAb,CAAf,CAAX,CAFT,EAEsD,EAFtD,EAGVQ,IAHU,CAGLb,SAHK,CAAb;AAKA,QAAMc,OAAO,GAAG,EAAhB,CARoC,CASpC;AACA;AACA;;AACA,MAAIT,CAAC,GAAGP,WAAR;AACA,MAAIiB,EAAJ;;AACA,KAAG;AACDD,IAAAA,OAAO,CAACE,IAAR,CAAazB,OAAO,CAACc,CAAD,EAAI,cAAJ,EAAoB,MAApB,CAApB;AACAU,IAAAA,EAAE,GAAGV,CAAL;AACAA,IAAAA,CAAC,GAAGb,OAAO,CAACa,CAAD,CAAX;AACD,GAJD,QAISA,CAAC,KAAKU,EAJf;;AAKAD,EAAAA,OAAO,CAACE,IAAR,CAAarB,WAAb,EAA0BM,IAA1B;AAEA,QAAMgB,OAAO,GAAGH,OAAO,CAACD,IAAR,CAAab,SAAb,CAAhB,CArBoC,CAuBpC;AACA;AACA;;AACA,OAAK,MAAMkB,GAAX,IAAkBhB,MAAM,CAACC,IAAP,CAAYJ,GAAZ,CAAlB,EAAoC;AAClC,QAAI,UAAUO,IAAV,CAAeY,GAAf,CAAJ,EACEnB,GAAG,CAACmB,GAAD,CAAH,GAAWD,OAAX;AACH;;AAED,SAAOlB,GAAP;AACD,CAhCD;;AAkCAoB,MAAM,CAACC,OAAP,GAAiBvB,OAAjB","sourcesContent":["const {resolve, dirname} = require('path')\nconst isWindows = require('./is-windows.js')\n// the path here is relative, even though it does not need to be\n// in order to make the posix tests pass in windows\nconst nodeGypPath = resolve(__dirname, '../lib/node-gyp-bin')\n\n// Windows typically calls its PATH environ 'Path', but this is not\n// guaranteed, nor is it guaranteed to be the only one.  Merge them\n// all together in the order they appear in the object.\nconst setPATH = (projectPath, env) => {\n  // not require('path').delimiter, because we fake this for testing\n  const delimiter = isWindows ? ';' : ':'\n  const PATH = Object.keys(env).filter(p => /^path$/i.test(p) && env[p])\n    .map(p => env[p].split(delimiter))\n    .reduce((set, p) => set.concat(p.filter(p => !set.includes(p))), [])\n    .join(delimiter)\n\n  const pathArr = []\n  // unshift the ./node_modules/.bin from every folder\n  // walk up until dirname() does nothing, at the root\n  // XXX should we specify a cwd that we don't go above?\n  let p = projectPath\n  let pp\n  do {\n    pathArr.push(resolve(p, 'node_modules', '.bin'))\n    pp = p\n    p = dirname(p)\n  } while (p !== pp)\n  pathArr.push(nodeGypPath, PATH)\n\n  const pathVal = pathArr.join(delimiter)\n\n  // XXX include the node-gyp-bin path somehow?  Probably better for\n  // npm or arborist or whoever to just provide that by putting it in\n  // the PATH environ, since that's preserved anyway.\n  for (const key of Object.keys(env)) {\n    if (/^path$/i.test(key))\n      env[key] = pathVal\n  }\n\n  return env\n}\n\nmodule.exports = setPATH\n"]},"metadata":{},"sourceType":"script"}