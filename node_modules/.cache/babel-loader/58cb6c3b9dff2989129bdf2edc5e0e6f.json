{"ast":null,"code":"// to GET CONTENTS for folder at PATH (which may be a PACKAGE):\n// - if PACKAGE, read path/package.json\n//   - if bins in ../node_modules/.bin, add those to result\n// - if depth >= maxDepth, add PATH to result, and finish\n// - readdir(PATH, with file types)\n// - add all FILEs in PATH to result\n// - if PARENT:\n//   - if depth < maxDepth, add GET CONTENTS of all DIRs in PATH\n//   - else, add all DIRs in PATH\n// - if no parent\n//   - if no bundled deps,\n//     - if depth < maxDepth, add GET CONTENTS of DIRs in path except\n//       node_modules\n//     - else, add all DIRs in path other than node_modules\n//   - if has bundled deps,\n//     - get list of bundled deps\n//     - add GET CONTENTS of bundled deps, PACKAGE=true, depth + 1\nconst bundled = require('npm-bundled');\n\nconst {\n  promisify\n} = require('util');\n\nconst fs = require('fs');\n\nconst readFile = promisify(fs.readFile);\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\n\nconst {\n  relative,\n  resolve,\n  basename,\n  dirname\n} = require('path');\n\nconst normalizePackageBin = require('npm-normalize-package-bin');\n\nconst readPackage = _ref => {\n  let {\n    path,\n    packageJsonCache\n  } = _ref;\n  return packageJsonCache.has(path) ? Promise.resolve(packageJsonCache.get(path)) : readFile(path).then(json => {\n    const pkg = normalizePackageBin(JSON.parse(json));\n    packageJsonCache.set(path, pkg);\n    return pkg;\n  }).catch(er => null);\n}; // just normalize bundle deps and bin, that's all we care about here.\n\n\nconst normalized = Symbol('package data has been normalized');\n\nconst rpj = _ref2 => {\n  let {\n    path,\n    packageJsonCache\n  } = _ref2;\n  return readPackage({\n    path,\n    packageJsonCache\n  }).then(pkg => {\n    if (!pkg || pkg[normalized]) return pkg;\n\n    if (pkg.bundledDependencies && !pkg.bundleDependencies) {\n      pkg.bundleDependencies = pkg.bundledDependencies;\n      delete pkg.bundledDependencies;\n    }\n\n    const bd = pkg.bundleDependencies;\n\n    if (bd === true) {\n      pkg.bundleDependencies = [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.optionalDependencies || {})];\n    }\n\n    if (typeof bd === 'object' && !Array.isArray(bd)) {\n      pkg.bundleDependencies = Object.keys(bd);\n    }\n\n    pkg[normalized] = true;\n    return pkg;\n  });\n};\n\nconst pkgContents = async _ref3 => {\n  let {\n    path,\n    depth,\n    currentDepth = 0,\n    pkg = null,\n    result = null,\n    packageJsonCache = null\n  } = _ref3;\n  if (!result) result = new Set();\n  if (!packageJsonCache) packageJsonCache = new Map();\n\n  if (pkg === true) {\n    return rpj({\n      path: path + '/package.json',\n      packageJsonCache\n    }).then(pkg => pkgContents({\n      path,\n      depth,\n      currentDepth,\n      pkg,\n      result,\n      packageJsonCache\n    }));\n  }\n\n  if (pkg) {\n    // add all bins to result if they exist\n    if (pkg.bin) {\n      const dir = dirname(path);\n      const base = basename(path);\n      const scope = basename(dir);\n      const nm = /^@.+/.test(scope) ? dirname(dir) : dir;\n      const binFiles = [];\n      Object.keys(pkg.bin).forEach(b => {\n        const base = resolve(nm, '.bin', b);\n        binFiles.push(base, base + '.cmd', base + '.ps1');\n      });\n      const bins = await Promise.all(binFiles.map(b => stat(b).then(() => b).catch(er => null)));\n      bins.filter(b => b).forEach(b => result.add(b));\n    }\n  }\n\n  if (currentDepth >= depth) {\n    result.add(path);\n    return result;\n  } // we'll need bundle list later, so get that now in parallel\n\n\n  const [dirEntries, bundleDeps] = await Promise.all([readdir(path, {\n    withFileTypes: true\n  }), currentDepth === 0 && pkg && pkg.bundleDependencies ? bundled({\n    path,\n    packageJsonCache\n  }) : null]).catch(() => []); // not a thing, probably a missing folder\n\n  if (!dirEntries) return result; // empty folder, just add the folder itself to the result\n\n  if (!dirEntries.length && !bundleDeps && currentDepth !== 0) {\n    result.add(path);\n    return result;\n  }\n\n  const recursePromises = []; // if we didn't get withFileTypes support, tack that on\n\n  if (typeof dirEntries[0] === 'string') {\n    // use a map so we can return a promise, but we mutate dirEntries in place\n    // this is much slower than getting the entries from the readdir call,\n    // but polyfills support for node versions before 10.10\n    await Promise.all(dirEntries.map(async (name, index) => {\n      const p = resolve(path, name);\n      const st = await lstat(p);\n      dirEntries[index] = Object.assign(st, {\n        name\n      });\n    }));\n  }\n\n  for (const entry of dirEntries) {\n    const p = resolve(path, entry.name);\n\n    if (entry.isDirectory() === false) {\n      result.add(p);\n      continue;\n    }\n\n    if (currentDepth !== 0 || entry.name !== 'node_modules') {\n      if (currentDepth < depth - 1) {\n        recursePromises.push(pkgContents({\n          path: p,\n          packageJsonCache,\n          depth,\n          currentDepth: currentDepth + 1,\n          result\n        }));\n      } else {\n        result.add(p);\n      }\n\n      continue;\n    }\n  }\n\n  if (bundleDeps) {\n    // bundle deps are all folders\n    // we always recurse to get pkg bins, but if currentDepth is too high,\n    // it'll return early before walking their contents.\n    recursePromises.push(...bundleDeps.map(dep => {\n      const p = resolve(path, 'node_modules', dep);\n      return pkgContents({\n        path: p,\n        packageJsonCache,\n        pkg: true,\n        depth,\n        currentDepth: currentDepth + 1,\n        result\n      });\n    }));\n  }\n\n  if (recursePromises.length) await Promise.all(recursePromises);\n  return result;\n};\n\nmodule.exports = _ref4 => {\n  let {\n    path,\n    depth = 1,\n    packageJsonCache\n  } = _ref4;\n  return pkgContents({\n    path: resolve(path),\n    depth,\n    pkg: true,\n    packageJsonCache\n  }).then(results => [...results]);\n};\n\nif (require.main === module) {\n  const options = {\n    path: null,\n    depth: 1\n  };\n  const usage = `Usage:\n  installed-package-contents <path> [-d<n> --depth=<n>]\n\nLists the files installed for a package specified by <path>.\n\nOptions:\n  -d<n> --depth=<n>   Provide a numeric value (\"Infinity\" is allowed)\n                      to specify how deep in the file tree to traverse.\n                      Default=1\n  -h --help           Show this usage information`;\n  process.argv.slice(2).forEach(arg => {\n    let match;\n    if ((match = arg.match(/^--depth=([0-9]+|Infinity)/)) || (match = arg.match(/^-d([0-9]+|Infinity)/))) options.depth = +match[1];else if (arg === '-h' || arg === '--help') {\n      console.log(usage);\n      process.exit(0);\n    } else options.path = arg;\n  });\n\n  if (!options.path) {\n    console.error('ERROR: no path provided');\n    console.error(usage);\n    process.exit(1);\n  }\n\n  const cwd = process.cwd();\n  module.exports(options).then(list => list.sort().forEach(p => console.log(relative(cwd, p)))).catch(\n  /* istanbul ignore next - pretty unusual */\n  er => {\n    console.error(er);\n    process.exit(1);\n  });\n}","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/@npmcli/installed-package-contents/index.js"],"names":["bundled","require","promisify","fs","readFile","readdir","stat","lstat","relative","resolve","basename","dirname","normalizePackageBin","readPackage","path","packageJsonCache","has","Promise","get","then","json","pkg","JSON","parse","set","catch","er","normalized","Symbol","rpj","bundledDependencies","bundleDependencies","bd","Object","keys","dependencies","optionalDependencies","Array","isArray","pkgContents","depth","currentDepth","result","Set","Map","bin","dir","base","scope","nm","test","binFiles","forEach","b","push","bins","all","map","filter","add","dirEntries","bundleDeps","withFileTypes","length","recursePromises","name","index","p","st","assign","entry","isDirectory","dep","module","exports","results","main","options","usage","process","argv","slice","arg","match","console","log","exit","error","cwd","list","sort"],"mappings":"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","sourcesContent":["// to GET CONTENTS for folder at PATH (which may be a PACKAGE):\n// - if PACKAGE, read path/package.json\n//   - if bins in ../node_modules/.bin, add those to result\n// - if depth >= maxDepth, add PATH to result, and finish\n// - readdir(PATH, with file types)\n// - add all FILEs in PATH to result\n// - if PARENT:\n//   - if depth < maxDepth, add GET CONTENTS of all DIRs in PATH\n//   - else, add all DIRs in PATH\n// - if no parent\n//   - if no bundled deps,\n//     - if depth < maxDepth, add GET CONTENTS of DIRs in path except\n//       node_modules\n//     - else, add all DIRs in path other than node_modules\n//   - if has bundled deps,\n//     - get list of bundled deps\n//     - add GET CONTENTS of bundled deps, PACKAGE=true, depth + 1\n\nconst bundled = require('npm-bundled')\nconst {promisify} = require('util')\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\nconst readdir = promisify(fs.readdir)\nconst stat = promisify(fs.stat)\nconst lstat = promisify(fs.lstat)\nconst {relative, resolve, basename, dirname} = require('path')\nconst normalizePackageBin = require('npm-normalize-package-bin')\n\nconst readPackage = ({ path, packageJsonCache }) =>\n  packageJsonCache.has(path) ? Promise.resolve(packageJsonCache.get(path))\n  : readFile(path).then(json => {\n      const pkg = normalizePackageBin(JSON.parse(json))\n      packageJsonCache.set(path, pkg)\n      return pkg\n    })\n    .catch(er => null)\n\n// just normalize bundle deps and bin, that's all we care about here.\nconst normalized = Symbol('package data has been normalized')\nconst rpj = ({ path, packageJsonCache }) =>\n  readPackage({path, packageJsonCache})\n  .then(pkg => {\n    if (!pkg || pkg[normalized])\n      return pkg\n    if (pkg.bundledDependencies && !pkg.bundleDependencies) {\n      pkg.bundleDependencies = pkg.bundledDependencies\n      delete pkg.bundledDependencies\n    }\n    const bd = pkg.bundleDependencies\n    if (bd === true) {\n      pkg.bundleDependencies = [\n        ...Object.keys(pkg.dependencies || {}),\n        ...Object.keys(pkg.optionalDependencies || {}),\n      ]\n    }\n    if (typeof bd === 'object' && !Array.isArray(bd)) {\n      pkg.bundleDependencies = Object.keys(bd)\n    }\n    pkg[normalized] = true\n    return pkg\n  })\n\n\nconst pkgContents = async ({\n  path,\n  depth,\n  currentDepth = 0,\n  pkg = null,\n  result = null,\n  packageJsonCache = null,\n}) => {\n  if (!result)\n    result = new Set()\n\n  if (!packageJsonCache)\n    packageJsonCache = new Map()\n\n  if (pkg === true) {\n    return rpj({ path: path + '/package.json', packageJsonCache })\n      .then(pkg => pkgContents({\n        path,\n        depth,\n        currentDepth,\n        pkg,\n        result,\n        packageJsonCache,\n      }))\n  }\n\n  if (pkg) {\n    // add all bins to result if they exist\n    if (pkg.bin) {\n      const dir = dirname(path)\n      const base = basename(path)\n      const scope = basename(dir)\n      const nm = /^@.+/.test(scope) ? dirname(dir) : dir\n\n      const binFiles = []\n      Object.keys(pkg.bin).forEach(b => {\n        const base = resolve(nm, '.bin', b)\n        binFiles.push(base, base + '.cmd', base + '.ps1')\n      })\n\n      const bins = await Promise.all(\n        binFiles.map(b => stat(b).then(() => b).catch((er) => null))\n      )\n      bins.filter(b => b).forEach(b => result.add(b))\n    }\n  }\n\n  if (currentDepth >= depth) {\n    result.add(path)\n    return result\n  }\n\n  // we'll need bundle list later, so get that now in parallel\n  const [dirEntries, bundleDeps] = await Promise.all([\n    readdir(path, { withFileTypes: true }),\n    currentDepth === 0 && pkg && pkg.bundleDependencies\n      ? bundled({ path, packageJsonCache }) : null,\n  ]).catch(() => [])\n\n  // not a thing, probably a missing folder\n  if (!dirEntries)\n    return result\n\n  // empty folder, just add the folder itself to the result\n  if (!dirEntries.length && !bundleDeps && currentDepth !== 0) {\n    result.add(path)\n    return result\n  }\n\n  const recursePromises = []\n\n  // if we didn't get withFileTypes support, tack that on\n  if (typeof dirEntries[0] === 'string') {\n    // use a map so we can return a promise, but we mutate dirEntries in place\n    // this is much slower than getting the entries from the readdir call,\n    // but polyfills support for node versions before 10.10\n    await Promise.all(dirEntries.map(async (name, index) => {\n      const p = resolve(path, name)\n      const st = await lstat(p)\n      dirEntries[index] = Object.assign(st, {name})\n    }))\n  }\n\n  for (const entry of dirEntries) {\n    const p = resolve(path, entry.name)\n    if (entry.isDirectory() === false) {\n      result.add(p)\n      continue\n    }\n\n    if (currentDepth !== 0 || entry.name !== 'node_modules') {\n      if (currentDepth < depth - 1) {\n        recursePromises.push(pkgContents({\n          path: p,\n          packageJsonCache,\n          depth,\n          currentDepth: currentDepth + 1,\n          result,\n        }))\n      } else {\n        result.add(p)\n      }\n      continue\n    }\n  }\n\n  if (bundleDeps) {\n    // bundle deps are all folders\n    // we always recurse to get pkg bins, but if currentDepth is too high,\n    // it'll return early before walking their contents.\n    recursePromises.push(...bundleDeps.map(dep => {\n      const p = resolve(path, 'node_modules', dep)\n      return pkgContents({\n        path: p,\n        packageJsonCache,\n        pkg: true,\n        depth,\n        currentDepth: currentDepth + 1,\n        result,\n      })\n    }))\n  }\n\n  if (recursePromises.length)\n    await Promise.all(recursePromises)\n\n  return result\n}\n\nmodule.exports = ({path, depth = 1, packageJsonCache}) => pkgContents({\n  path: resolve(path),\n  depth,\n  pkg: true,\n  packageJsonCache,\n}).then(results => [...results])\n\n\nif (require.main === module) {\n  const options = { path: null, depth: 1 }\n  const usage = `Usage:\n  installed-package-contents <path> [-d<n> --depth=<n>]\n\nLists the files installed for a package specified by <path>.\n\nOptions:\n  -d<n> --depth=<n>   Provide a numeric value (\"Infinity\" is allowed)\n                      to specify how deep in the file tree to traverse.\n                      Default=1\n  -h --help           Show this usage information`\n\n  process.argv.slice(2).forEach(arg => {\n    let match\n    if ((match = arg.match(/^--depth=([0-9]+|Infinity)/)) ||\n        (match = arg.match(/^-d([0-9]+|Infinity)/)))\n      options.depth = +match[1]\n    else if (arg === '-h' || arg === '--help') {\n      console.log(usage)\n      process.exit(0)\n    } else\n      options.path = arg\n  })\n  if (!options.path)  {\n    console.error('ERROR: no path provided')\n    console.error(usage)\n    process.exit(1)\n  }\n  const cwd = process.cwd()\n  module.exports(options)\n    .then(list => list.sort().forEach(p => console.log(relative(cwd, p))))\n    .catch(/* istanbul ignore next - pretty unusual */ er => {\n      console.error(er)\n      process.exit(1)\n    })\n}\n"]},"metadata":{},"sourceType":"script"}