{"ast":null,"code":"const Minipass = require('minipass');\n\nconst MinipassPipeline = require('minipass-pipeline');\n\nconst fetch = require('minipass-fetch');\n\nconst promiseRetry = require('promise-retry');\n\nconst ssri = require('ssri');\n\nconst getAgent = require('./agent.js');\n\nconst pkg = require('../package.json');\n\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`;\nconst RETRY_ERRORS = ['ECONNRESET', // remote socket closed on us\n'ECONNREFUSED', // remote host refused to open connection\n'EADDRINUSE', // failed to bind to a local port (proxy?)\n'ETIMEDOUT', // someone in the transaction is WAY TOO SLOW\n'ERR_SOCKET_TIMEOUT' // same as above, but this one comes from agentkeepalive\n// Known codes we do NOT retry on:\n// ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n];\nconst RETRY_TYPES = ['request-timeout']; // make a request directly to the remote source,\n// retrying certain classes of errors as well as\n// following redirects (through the cache if necessary)\n// and verifying response integrity\n\nconst remoteFetch = (request, options) => {\n  const agent = getAgent(request.url, options);\n  if (!request.headers.has('connection')) request.headers.set('connection', agent ? 'keep-alive' : 'close');\n  if (!request.headers.has('user-agent')) request.headers.set('user-agent', USER_AGENT); // keep our own options since we're overriding the agent\n  // and the redirect mode\n\n  const _opts = { ...options,\n    agent,\n    redirect: 'manual'\n  };\n  return promiseRetry(async (retryHandler, attemptNum) => {\n    const req = new fetch.Request(request, _opts);\n\n    try {\n      let res = await fetch(req, _opts);\n\n      if (_opts.integrity && res.status === 200) {\n        // we got a 200 response and the user has specified an expected\n        // integrity value, so wrap the response in an ssri stream to verify it\n        const integrityStream = ssri.integrityStream({\n          integrity: _opts.integrity\n        });\n        res = new fetch.Response(new MinipassPipeline(res.body, integrityStream), res);\n      }\n\n      res.headers.set('x-fetch-attempts', attemptNum); // do not retry POST requests, or requests with a streaming body\n      // do retry requests with a 408, 420, 429 or 500+ status in the response\n\n      const isStream = Minipass.isStream(req.body);\n      const isRetriable = req.method !== 'POST' && !isStream && ([408, 420, 429].includes(res.status) || res.status >= 500);\n\n      if (isRetriable) {\n        if (typeof options.onRetry === 'function') options.onRetry(res);\n        return retryHandler(res);\n      }\n\n      return res;\n    } catch (err) {\n      const code = err.code === 'EPROMISERETRY' ? err.retried.code : err.code; // err.retried will be the thing that was thrown from above\n      // if it's a response, we just got a bad status code and we\n      // can re-throw to allow the retry\n\n      const isRetryError = err.retried instanceof fetch.Response || RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type);\n      if (req.method === 'POST' || isRetryError) throw err;\n      if (typeof options.onRetry === 'function') options.onRetry(err);\n      return retryHandler(err);\n    }\n  }, options.retry).catch(err => {\n    // don't reject for http errors, just return them\n    if (err.status >= 400 && err.type !== 'system') return err;\n    throw err;\n  });\n};\n\nmodule.exports = remoteFetch;","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/make-fetch-happen/lib/remote.js"],"names":["Minipass","require","MinipassPipeline","fetch","promiseRetry","ssri","getAgent","pkg","USER_AGENT","name","version","RETRY_ERRORS","RETRY_TYPES","remoteFetch","request","options","agent","url","headers","has","set","_opts","redirect","retryHandler","attemptNum","req","Request","res","integrity","status","integrityStream","Response","body","isStream","isRetriable","method","includes","onRetry","err","code","retried","isRetryError","type","retry","catch","module","exports"],"mappings":"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","sourcesContent":["const Minipass = require('minipass')\nconst MinipassPipeline = require('minipass-pipeline')\nconst fetch = require('minipass-fetch')\nconst promiseRetry = require('promise-retry')\nconst ssri = require('ssri')\n\nconst getAgent = require('./agent.js')\nconst pkg = require('../package.json')\n\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`\n\nconst RETRY_ERRORS = [\n  'ECONNRESET', // remote socket closed on us\n  'ECONNREFUSED', // remote host refused to open connection\n  'EADDRINUSE', // failed to bind to a local port (proxy?)\n  'ETIMEDOUT', // someone in the transaction is WAY TOO SLOW\n  'ERR_SOCKET_TIMEOUT', // same as above, but this one comes from agentkeepalive\n  // Known codes we do NOT retry on:\n  // ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n]\n\nconst RETRY_TYPES = [\n  'request-timeout',\n]\n\n// make a request directly to the remote source,\n// retrying certain classes of errors as well as\n// following redirects (through the cache if necessary)\n// and verifying response integrity\nconst remoteFetch = (request, options) => {\n  const agent = getAgent(request.url, options)\n  if (!request.headers.has('connection'))\n    request.headers.set('connection', agent ? 'keep-alive' : 'close')\n\n  if (!request.headers.has('user-agent'))\n    request.headers.set('user-agent', USER_AGENT)\n\n  // keep our own options since we're overriding the agent\n  // and the redirect mode\n  const _opts = {\n    ...options,\n    agent,\n    redirect: 'manual',\n  }\n\n  return promiseRetry(async (retryHandler, attemptNum) => {\n    const req = new fetch.Request(request, _opts)\n    try {\n      let res = await fetch(req, _opts)\n      if (_opts.integrity && res.status === 200) {\n        // we got a 200 response and the user has specified an expected\n        // integrity value, so wrap the response in an ssri stream to verify it\n        const integrityStream = ssri.integrityStream({ integrity: _opts.integrity })\n        res = new fetch.Response(new MinipassPipeline(res.body, integrityStream), res)\n      }\n\n      res.headers.set('x-fetch-attempts', attemptNum)\n\n      // do not retry POST requests, or requests with a streaming body\n      // do retry requests with a 408, 420, 429 or 500+ status in the response\n      const isStream = Minipass.isStream(req.body)\n      const isRetriable = req.method !== 'POST' &&\n          !isStream &&\n          ([408, 420, 429].includes(res.status) || res.status >= 500)\n\n      if (isRetriable) {\n        if (typeof options.onRetry === 'function')\n          options.onRetry(res)\n\n        return retryHandler(res)\n      }\n\n      return res\n    } catch (err) {\n      const code = (err.code === 'EPROMISERETRY')\n        ? err.retried.code\n        : err.code\n\n      // err.retried will be the thing that was thrown from above\n      // if it's a response, we just got a bad status code and we\n      // can re-throw to allow the retry\n      const isRetryError = err.retried instanceof fetch.Response ||\n        (RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type))\n\n      if (req.method === 'POST' || isRetryError)\n        throw err\n\n      if (typeof options.onRetry === 'function')\n        options.onRetry(err)\n\n      return retryHandler(err)\n    }\n  }, options.retry).catch((err) => {\n    // don't reject for http errors, just return them\n    if (err.status >= 400 && err.type !== 'system')\n      return err\n\n    throw err\n  })\n}\n\nmodule.exports = remoteFetch\n"]},"metadata":{},"sourceType":"script"}