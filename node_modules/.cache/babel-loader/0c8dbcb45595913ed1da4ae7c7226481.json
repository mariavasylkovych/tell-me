{"ast":null,"code":"'use strict';\n\nconst Url = require('url');\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst zlib = require('minizlib');\n\nconst Minipass = require('minipass');\n\nconst Body = require('./body.js');\n\nconst {\n  writeToStream,\n  getTotalBytes\n} = Body;\n\nconst Response = require('./response.js');\n\nconst Headers = require('./headers.js');\n\nconst {\n  createHeadersLenient\n} = Headers;\n\nconst Request = require('./request.js');\n\nconst {\n  getNodeRequestOptions\n} = Request;\n\nconst FetchError = require('./fetch-error.js');\n\nconst AbortError = require('./abort-error.js');\n\nconst resolveUrl = Url.resolve;\n\nconst fetch = (url, opts) => {\n  if (/^data:/.test(url)) {\n    const request = new Request(url, opts);\n\n    try {\n      const split = url.split(',');\n      const data = Buffer.from(split[1], 'base64');\n      const type = split[0].match(/^data:(.*);base64$/)[1];\n      return Promise.resolve(new Response(data, {\n        headers: {\n          'Content-Type': type,\n          'Content-Length': data.length\n        }\n      }));\n    } catch (er) {\n      return Promise.reject(new FetchError(`[${request.method}] ${request.url} invalid URL, ${er.message}`, 'system', er));\n    }\n  }\n\n  return new Promise((resolve, reject) => {\n    // build request object\n    const request = new Request(url, opts);\n    let options;\n\n    try {\n      options = getNodeRequestOptions(request);\n    } catch (er) {\n      return reject(er);\n    }\n\n    const send = (options.protocol === 'https:' ? https : http).request;\n    const {\n      signal\n    } = request;\n    let response = null;\n\n    const abort = () => {\n      const error = new AbortError('The user aborted a request.');\n      reject(error);\n\n      if (Minipass.isStream(request.body) && typeof request.body.destroy === 'function') {\n        request.body.destroy(error);\n      }\n\n      if (response && response.body) {\n        response.body.emit('error', error);\n      }\n    };\n\n    if (signal && signal.aborted) return abort();\n\n    const abortAndFinalize = () => {\n      abort();\n      finalize();\n    };\n\n    const finalize = () => {\n      req.abort();\n      if (signal) signal.removeEventListener('abort', abortAndFinalize);\n      clearTimeout(reqTimeout);\n    }; // send request\n\n\n    const req = send(options);\n    if (signal) signal.addEventListener('abort', abortAndFinalize);\n    let reqTimeout = null;\n\n    if (request.timeout) {\n      req.once('socket', socket => {\n        reqTimeout = setTimeout(() => {\n          reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n          finalize();\n        }, request.timeout);\n      });\n    }\n\n    req.on('error', er => {\n      // if a 'response' event is emitted before the 'error' event, then by the\n      // time this handler is run it's too late to reject the Promise for the\n      // response. instead, we forward the error event to the response stream\n      // so that the error will surface to the user when they try to consume\n      // the body. this is done as a side effect of aborting the request except\n      // for in windows, where we must forward the event manually, otherwise\n      // there is no longer a ref'd socket attached to the request and the\n      // stream never ends so the event loop runs out of work and the process\n      // exits without warning.\n      // coverage skipped here due to the difficulty in testing\n      // istanbul ignore next\n      if (req.res) req.res.emit('error', er);\n      reject(new FetchError(`request to ${request.url} failed, reason: ${er.message}`, 'system', er));\n      finalize();\n    });\n    req.on('response', res => {\n      clearTimeout(reqTimeout);\n      const headers = createHeadersLenient(res.headers); // HTTP fetch step 5\n\n      if (fetch.isRedirect(res.statusCode)) {\n        // HTTP fetch step 5.2\n        const location = headers.get('Location'); // HTTP fetch step 5.3\n\n        const locationURL = location === null ? null : resolveUrl(request.url, location); // HTTP fetch step 5.5\n\n        switch (request.redirect) {\n          case 'error':\n            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n            finalize();\n            return;\n\n          case 'manual':\n            // node-fetch-specific step: make manual redirect a bit easier to\n            // use by setting the Location header value to the resolved URL.\n            if (locationURL !== null) {\n              // handle corrupted header\n              try {\n                headers.set('Location', locationURL);\n              } catch (err) {\n                /* istanbul ignore next: nodejs server prevent invalid\n                   response headers, we can't test this through normal\n                   request */\n                reject(err);\n              }\n            }\n\n            break;\n\n          case 'follow':\n            // HTTP-redirect fetch step 2\n            if (locationURL === null) {\n              break;\n            } // HTTP-redirect fetch step 5\n\n\n            if (request.counter >= request.follow) {\n              reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n              finalize();\n              return;\n            } // HTTP-redirect fetch step 9\n\n\n            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n              reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n              finalize();\n              return;\n            } // Update host due to redirection\n\n\n            request.headers.set('host', Url.parse(locationURL).host); // HTTP-redirect fetch step 6 (counter increment)\n            // Create a new Request object.\n\n            const requestOpts = {\n              headers: new Headers(request.headers),\n              follow: request.follow,\n              counter: request.counter + 1,\n              agent: request.agent,\n              compress: request.compress,\n              method: request.method,\n              body: request.body,\n              signal: request.signal,\n              timeout: request.timeout\n            }; // HTTP-redirect fetch step 11\n\n            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n              requestOpts.method = 'GET';\n              requestOpts.body = undefined;\n              requestOpts.headers.delete('content-length');\n            } // HTTP-redirect fetch step 15\n\n\n            resolve(fetch(new Request(locationURL, requestOpts)));\n            finalize();\n            return;\n        }\n      } // end if(isRedirect)\n      // prepare response\n\n\n      res.once('end', () => signal && signal.removeEventListener('abort', abortAndFinalize));\n      const body = new Minipass(); // exceedingly rare that the stream would have an error,\n      // but just in case we proxy it to the stream in use.\n\n      res.on('error',\n      /* istanbul ignore next */\n      er => body.emit('error', er));\n      res.on('data', chunk => body.write(chunk));\n      res.on('end', () => body.end());\n      const responseOptions = {\n        url: request.url,\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: headers,\n        size: request.size,\n        timeout: request.timeout,\n        counter: request.counter,\n        trailer: new Promise(resolve => res.on('end', () => resolve(createHeadersLenient(res.trailers))))\n      }; // HTTP-network fetch step 12.1.1.3\n\n      const codings = headers.get('Content-Encoding'); // HTTP-network fetch step 12.1.1.4: handle content codings\n      // in following scenarios we ignore compression support\n      // 1. compression support is disabled\n      // 2. HEAD request\n      // 3. no Content-Encoding header\n      // 4. no content response (204)\n      // 5. content not modified response (304)\n\n      if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n        response = new Response(body, responseOptions);\n        resolve(response);\n        return;\n      } // Be less strict when decoding compressed responses, since sometimes\n      // servers send slightly invalid responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n\n\n      const zlibOptions = {\n        flush: zlib.constants.Z_SYNC_FLUSH,\n        finishFlush: zlib.constants.Z_SYNC_FLUSH\n      }; // for gzip\n\n      if (codings == 'gzip' || codings == 'x-gzip') {\n        const unzip = new zlib.Gunzip(zlibOptions);\n        response = new Response( // exceedingly rare that the stream would have an error,\n        // but just in case we proxy it to the stream in use.\n        body.on('error',\n        /* istanbul ignore next */\n        er => unzip.emit('error', er)).pipe(unzip), responseOptions);\n        resolve(response);\n        return;\n      } // for deflate\n\n\n      if (codings == 'deflate' || codings == 'x-deflate') {\n        // handle the infamous raw deflate response from old servers\n        // a hack for old IIS and Apache servers\n        const raw = res.pipe(new Minipass());\n        raw.once('data', chunk => {\n          // see http://stackoverflow.com/questions/37519828\n          const decoder = (chunk[0] & 0x0F) === 0x08 ? new zlib.Inflate() : new zlib.InflateRaw(); // exceedingly rare that the stream would have an error,\n          // but just in case we proxy it to the stream in use.\n\n          body.on('error',\n          /* istanbul ignore next */\n          er => decoder.emit('error', er)).pipe(decoder);\n          response = new Response(decoder, responseOptions);\n          resolve(response);\n        });\n        return;\n      } // for br\n\n\n      if (codings == 'br') {\n        // ignoring coverage so tests don't have to fake support (or lack of) for brotli\n        // istanbul ignore next\n        try {\n          var decoder = new zlib.BrotliDecompress();\n        } catch (err) {\n          reject(err);\n          finalize();\n          return;\n        } // exceedingly rare that the stream would have an error,\n        // but just in case we proxy it to the stream in use.\n\n\n        body.on('error',\n        /* istanbul ignore next */\n        er => decoder.emit('error', er)).pipe(decoder);\n        response = new Response(decoder, responseOptions);\n        resolve(response);\n        return;\n      } // otherwise, use response as-is\n\n\n      response = new Response(body, responseOptions);\n      resolve(response);\n    });\n    writeToStream(req, request);\n  });\n};\n\nmodule.exports = fetch;\n\nfetch.isRedirect = code => code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n\nfetch.Headers = Headers;\nfetch.Request = Request;\nfetch.Response = Response;\nfetch.FetchError = FetchError;","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/minipass-fetch/lib/index.js"],"names":["Url","require","http","https","zlib","Minipass","Body","writeToStream","getTotalBytes","Response","Headers","createHeadersLenient","Request","getNodeRequestOptions","FetchError","AbortError","resolveUrl","resolve","fetch","url","opts","test","request","split","data","Buffer","from","type","match","Promise","headers","length","er","reject","method","message","options","send","protocol","signal","response","abort","error","isStream","body","destroy","emit","aborted","abortAndFinalize","finalize","req","removeEventListener","clearTimeout","reqTimeout","addEventListener","timeout","once","socket","setTimeout","on","res","isRedirect","statusCode","location","get","locationURL","redirect","set","err","counter","follow","parse","host","requestOpts","agent","compress","undefined","delete","chunk","write","end","responseOptions","status","statusText","statusMessage","size","trailer","trailers","codings","zlibOptions","flush","constants","Z_SYNC_FLUSH","finishFlush","unzip","Gunzip","pipe","raw","decoder","Inflate","InflateRaw","BrotliDecompress","module","exports","code"],"mappings":"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","sourcesContent":["'use strict'\nconst Url = require('url')\nconst http = require('http')\nconst https = require('https')\nconst zlib = require('minizlib')\nconst Minipass = require('minipass')\n\nconst Body = require('./body.js')\nconst { writeToStream, getTotalBytes } = Body\nconst Response = require('./response.js')\nconst Headers = require('./headers.js')\nconst { createHeadersLenient } = Headers\nconst Request = require('./request.js')\nconst { getNodeRequestOptions } = Request\nconst FetchError = require('./fetch-error.js')\nconst AbortError = require('./abort-error.js')\n\nconst resolveUrl = Url.resolve\n\nconst fetch = (url, opts) => {\n  if (/^data:/.test(url)) {\n    const request = new Request(url, opts)\n    try {\n      const split = url.split(',')\n      const data = Buffer.from(split[1], 'base64')\n      const type = split[0].match(/^data:(.*);base64$/)[1]\n      return Promise.resolve(new Response(data, {\n        headers: {\n          'Content-Type': type,\n          'Content-Length': data.length,\n        }\n      }))\n    } catch (er) {\n      return Promise.reject(new FetchError(`[${request.method}] ${\n        request.url} invalid URL, ${er.message}`, 'system', er))\n    }\n  }\n\n  return new Promise((resolve, reject) => {\n    // build request object\n    const request = new Request(url, opts)\n    let options\n    try {\n      options = getNodeRequestOptions(request)\n    } catch (er) {\n      return reject(er)\n    }\n\n    const send = (options.protocol === 'https:' ? https : http).request\n    const { signal } = request\n    let response = null\n    const abort = () => {\n      const error = new AbortError('The user aborted a request.')\n      reject(error)\n      if (Minipass.isStream(request.body) &&\n          typeof request.body.destroy === 'function') {\n        request.body.destroy(error)\n      }\n      if (response && response.body) {\n        response.body.emit('error', error)\n      }\n    }\n\n    if (signal && signal.aborted)\n      return abort()\n\n    const abortAndFinalize = () => {\n      abort()\n      finalize()\n    }\n\n    const finalize = () => {\n      req.abort()\n      if (signal)\n        signal.removeEventListener('abort', abortAndFinalize)\n      clearTimeout(reqTimeout)\n    }\n\n    // send request\n    const req = send(options)\n\n    if (signal)\n      signal.addEventListener('abort', abortAndFinalize)\n\n    let reqTimeout = null\n    if (request.timeout) {\n      req.once('socket', socket => {\n        reqTimeout = setTimeout(() => {\n          reject(new FetchError(`network timeout at: ${\n            request.url}`, 'request-timeout'))\n          finalize()\n        }, request.timeout)\n      })\n    }\n\n    req.on('error', er => {\n      // if a 'response' event is emitted before the 'error' event, then by the\n      // time this handler is run it's too late to reject the Promise for the\n      // response. instead, we forward the error event to the response stream\n      // so that the error will surface to the user when they try to consume\n      // the body. this is done as a side effect of aborting the request except\n      // for in windows, where we must forward the event manually, otherwise\n      // there is no longer a ref'd socket attached to the request and the\n      // stream never ends so the event loop runs out of work and the process\n      // exits without warning.\n      // coverage skipped here due to the difficulty in testing\n      // istanbul ignore next\n      if (req.res)\n        req.res.emit('error', er)\n      reject(new FetchError(`request to ${request.url} failed, reason: ${\n        er.message}`, 'system', er))\n      finalize()\n    })\n\n    req.on('response', res => {\n      clearTimeout(reqTimeout)\n\n      const headers = createHeadersLenient(res.headers)\n\n      // HTTP fetch step 5\n      if (fetch.isRedirect(res.statusCode)) {\n        // HTTP fetch step 5.2\n        const location = headers.get('Location')\n\n        // HTTP fetch step 5.3\n        const locationURL = location === null ? null\n          : resolveUrl(request.url, location)\n\n        // HTTP fetch step 5.5\n        switch (request.redirect) {\n          case 'error':\n            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${\n              request.url}`, 'no-redirect'))\n            finalize()\n            return\n\n          case 'manual':\n            // node-fetch-specific step: make manual redirect a bit easier to\n            // use by setting the Location header value to the resolved URL.\n            if (locationURL !== null) {\n              // handle corrupted header\n              try {\n                headers.set('Location', locationURL)\n              } catch (err) {\n                /* istanbul ignore next: nodejs server prevent invalid\n                   response headers, we can't test this through normal\n                   request */\n                reject(err)\n              }\n            }\n            break\n\n          case 'follow':\n            // HTTP-redirect fetch step 2\n            if (locationURL === null) {\n              break\n            }\n\n            // HTTP-redirect fetch step 5\n            if (request.counter >= request.follow) {\n              reject(new FetchError(`maximum redirect reached at: ${\n                request.url}`, 'max-redirect'))\n              finalize()\n              return\n            }\n\n            // HTTP-redirect fetch step 9\n            if (res.statusCode !== 303 &&\n                request.body &&\n                getTotalBytes(request) === null) {\n              reject(new FetchError(\n                'Cannot follow redirect with body being a readable stream',\n                'unsupported-redirect'\n              ))\n              finalize()\n              return\n            }\n\n            // Update host due to redirection\n            request.headers.set('host', Url.parse(locationURL).host)\n\n            // HTTP-redirect fetch step 6 (counter increment)\n            // Create a new Request object.\n            const requestOpts = {\n              headers: new Headers(request.headers),\n              follow: request.follow,\n              counter: request.counter + 1,\n              agent: request.agent,\n              compress: request.compress,\n              method: request.method,\n              body: request.body,\n              signal: request.signal,\n              timeout: request.timeout,\n            }\n\n            // HTTP-redirect fetch step 11\n            if (res.statusCode === 303 || (\n                (res.statusCode === 301 || res.statusCode === 302) &&\n                request.method === 'POST'\n            )) {\n              requestOpts.method = 'GET'\n              requestOpts.body = undefined\n              requestOpts.headers.delete('content-length')\n            }\n\n            // HTTP-redirect fetch step 15\n            resolve(fetch(new Request(locationURL, requestOpts)))\n            finalize()\n            return\n        }\n      } // end if(isRedirect)\n\n\n      // prepare response\n      res.once('end', () =>\n        signal && signal.removeEventListener('abort', abortAndFinalize))\n\n      const body = new Minipass()\n      // exceedingly rare that the stream would have an error,\n      // but just in case we proxy it to the stream in use.\n      res.on('error', /* istanbul ignore next */ er => body.emit('error', er))\n      res.on('data', (chunk) => body.write(chunk))\n      res.on('end', () => body.end())\n\n      const responseOptions = {\n        url: request.url,\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: headers,\n        size: request.size,\n        timeout: request.timeout,\n        counter: request.counter,\n        trailer: new Promise(resolve =>\n          res.on('end', () => resolve(createHeadersLenient(res.trailers))))\n      }\n\n      // HTTP-network fetch step 12.1.1.3\n      const codings = headers.get('Content-Encoding')\n\n      // HTTP-network fetch step 12.1.1.4: handle content codings\n\n      // in following scenarios we ignore compression support\n      // 1. compression support is disabled\n      // 2. HEAD request\n      // 3. no Content-Encoding header\n      // 4. no content response (204)\n      // 5. content not modified response (304)\n      if (!request.compress ||\n          request.method === 'HEAD' ||\n          codings === null ||\n          res.statusCode === 204 ||\n          res.statusCode === 304) {\n        response = new Response(body, responseOptions)\n        resolve(response)\n        return\n      }\n\n\n      // Be less strict when decoding compressed responses, since sometimes\n      // servers send slightly invalid responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n      const zlibOptions = {\n        flush: zlib.constants.Z_SYNC_FLUSH,\n        finishFlush: zlib.constants.Z_SYNC_FLUSH,\n      }\n\n      // for gzip\n      if (codings == 'gzip' || codings == 'x-gzip') {\n        const unzip = new zlib.Gunzip(zlibOptions)\n        response = new Response(\n          // exceedingly rare that the stream would have an error,\n          // but just in case we proxy it to the stream in use.\n          body.on('error', /* istanbul ignore next */ er => unzip.emit('error', er)).pipe(unzip),\n          responseOptions\n        )\n        resolve(response)\n        return\n      }\n\n      // for deflate\n      if (codings == 'deflate' || codings == 'x-deflate') {\n        // handle the infamous raw deflate response from old servers\n        // a hack for old IIS and Apache servers\n        const raw = res.pipe(new Minipass())\n        raw.once('data', chunk => {\n          // see http://stackoverflow.com/questions/37519828\n          const decoder = (chunk[0] & 0x0F) === 0x08\n            ? new zlib.Inflate()\n            : new zlib.InflateRaw()\n          // exceedingly rare that the stream would have an error,\n          // but just in case we proxy it to the stream in use.\n          body.on('error', /* istanbul ignore next */ er => decoder.emit('error', er)).pipe(decoder)\n          response = new Response(decoder, responseOptions)\n          resolve(response)\n        })\n        return\n      }\n\n\n      // for br\n      if (codings == 'br') {\n        // ignoring coverage so tests don't have to fake support (or lack of) for brotli\n        // istanbul ignore next\n        try {\n          var decoder = new zlib.BrotliDecompress()\n        } catch (err) {\n          reject(err)\n          finalize()\n          return\n        }\n        // exceedingly rare that the stream would have an error,\n        // but just in case we proxy it to the stream in use.\n        body.on('error', /* istanbul ignore next */ er => decoder.emit('error', er)).pipe(decoder)\n        response = new Response(decoder, responseOptions)\n        resolve(response)\n        return\n      }\n\n      // otherwise, use response as-is\n      response = new Response(body, responseOptions)\n      resolve(response)\n    })\n\n    writeToStream(req, request)\n  })\n}\n\nmodule.exports = fetch\n\nfetch.isRedirect = code =>\n  code === 301 ||\n  code === 302 ||\n  code === 303 ||\n  code === 307 ||\n  code === 308\n\nfetch.Headers = Headers\nfetch.Request = Request\nfetch.Response = Response\nfetch.FetchError = FetchError\n"]},"metadata":{},"sourceType":"script"}