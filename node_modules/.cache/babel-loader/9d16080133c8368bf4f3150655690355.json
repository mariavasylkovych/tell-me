{"ast":null,"code":"'use strict';\n\nconst npa = require('npm-package-arg'); // Find the longest registry key that is used for some kind of auth\n// in the options.\n\n\nconst regKeyFromURI = (uri, opts) => {\n  const parsed = new URL(uri); // try to find a config key indicating we have auth for this registry\n  // can be one of :_authToken, :_auth, or :_password and :username\n  // We walk up the \"path\" until we're left with just //<host>[:<port>],\n  // stopping when we reach '//'.\n\n  let regKey = `//${parsed.host}${parsed.pathname}`;\n\n  while (regKey.length > '//'.length) {\n    // got some auth for this URI\n    if (hasAuth(regKey, opts)) return regKey; // can be either //host/some/path/:_auth or //host/some/path:_auth\n    // walk up by removing EITHER what's after the slash OR the slash itself\n\n    regKey = regKey.replace(/([^/]+|\\/)$/, '');\n  }\n};\n\nconst hasAuth = (regKey, opts) => opts[`${regKey}:_authToken`] || opts[`${regKey}:_auth`] || opts[`${regKey}:username`] && opts[`${regKey}:_password`];\n\nconst sameHost = (a, b) => {\n  const parsedA = new URL(a);\n  const parsedB = new URL(b);\n  return parsedA.host === parsedB.host;\n};\n\nconst getRegistry = opts => {\n  const {\n    spec\n  } = opts;\n  const {\n    scope: specScope,\n    subSpec\n  } = spec ? npa(spec) : {};\n  const subSpecScope = subSpec && subSpec.scope;\n  const scope = subSpec ? subSpecScope : specScope;\n  const scopeReg = scope && opts[`${scope}:registry`];\n  return scopeReg || opts.registry;\n};\n\nconst getAuth = function (uri) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    forceAuth\n  } = opts;\n  if (!uri) throw new Error('URI is required');\n  const regKey = regKeyFromURI(uri, forceAuth || opts); // we are only allowed to use what's in forceAuth if specified\n\n  if (forceAuth && !regKey) {\n    return new Auth({\n      scopeAuthKey: null,\n      token: forceAuth._authToken || forceAuth.token,\n      username: forceAuth.username,\n      password: forceAuth._password || forceAuth.password,\n      auth: forceAuth._auth || forceAuth.auth\n    });\n  } // no auth for this URI, but might have it for the registry\n\n\n  if (!regKey) {\n    const registry = getRegistry(opts);\n    if (registry && uri !== registry && sameHost(uri, registry)) return getAuth(registry, opts);else if (registry !== opts.registry) {\n      // If making a tarball request to a different base URI than the\n      // registry where we logged in, but the same auth SHOULD be sent\n      // to that artifact host, then we track where it was coming in from,\n      // and warn the user if we get a 4xx error on it.\n      const scopeAuthKey = regKeyFromURI(registry, opts);\n      return new Auth({\n        scopeAuthKey\n      });\n    }\n  }\n\n  const {\n    [`${regKey}:_authToken`]: token,\n    [`${regKey}:username`]: username,\n    [`${regKey}:_password`]: password,\n    [`${regKey}:_auth`]: auth\n  } = opts;\n  return new Auth({\n    scopeAuthKey: null,\n    token,\n    auth,\n    username,\n    password\n  });\n};\n\nclass Auth {\n  constructor(_ref) {\n    let {\n      token,\n      auth,\n      username,\n      password,\n      scopeAuthKey\n    } = _ref;\n    this.scopeAuthKey = scopeAuthKey;\n    this.token = null;\n    this.auth = null;\n    this.isBasicAuth = false;\n    if (token) this.token = token;else if (auth) this.auth = auth;else if (username && password) {\n      const p = Buffer.from(password, 'base64').toString('utf8');\n      this.auth = Buffer.from(`${username}:${p}`, 'utf8').toString('base64');\n      this.isBasicAuth = true;\n    }\n  }\n\n}\n\nmodule.exports = getAuth;","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/npm-registry-fetch/auth.js"],"names":["npa","require","regKeyFromURI","uri","opts","parsed","URL","regKey","host","pathname","length","hasAuth","replace","sameHost","a","b","parsedA","parsedB","getRegistry","spec","scope","specScope","subSpec","subSpecScope","scopeReg","registry","getAuth","forceAuth","Error","Auth","scopeAuthKey","token","_authToken","username","password","_password","auth","_auth","constructor","isBasicAuth","p","Buffer","from","toString","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst npa = require('npm-package-arg')\n\n// Find the longest registry key that is used for some kind of auth\n// in the options.\nconst regKeyFromURI = (uri, opts) => {\n  const parsed = new URL(uri)\n  // try to find a config key indicating we have auth for this registry\n  // can be one of :_authToken, :_auth, or :_password and :username\n  // We walk up the \"path\" until we're left with just //<host>[:<port>],\n  // stopping when we reach '//'.\n  let regKey = `//${parsed.host}${parsed.pathname}`\n  while (regKey.length > '//'.length) {\n    // got some auth for this URI\n    if (hasAuth(regKey, opts))\n      return regKey\n\n    // can be either //host/some/path/:_auth or //host/some/path:_auth\n    // walk up by removing EITHER what's after the slash OR the slash itself\n    regKey = regKey.replace(/([^/]+|\\/)$/, '')\n  }\n}\n\nconst hasAuth = (regKey, opts) => (\n  opts[`${regKey}:_authToken`] ||\n  opts[`${regKey}:_auth`] ||\n  opts[`${regKey}:username`] && opts[`${regKey}:_password`]\n)\n\nconst sameHost = (a, b) => {\n  const parsedA = new URL(a)\n  const parsedB = new URL(b)\n  return parsedA.host === parsedB.host\n}\n\nconst getRegistry = opts => {\n  const { spec } = opts\n  const { scope: specScope, subSpec } = spec ? npa(spec) : {}\n  const subSpecScope = subSpec && subSpec.scope\n  const scope = subSpec ? subSpecScope : specScope\n  const scopeReg = scope && opts[`${scope}:registry`]\n  return scopeReg || opts.registry\n}\n\nconst getAuth = (uri, opts = {}) => {\n  const { forceAuth } = opts\n  if (!uri)\n    throw new Error('URI is required')\n  const regKey = regKeyFromURI(uri, forceAuth || opts)\n\n  // we are only allowed to use what's in forceAuth if specified\n  if (forceAuth && !regKey) {\n    return new Auth({\n      scopeAuthKey: null,\n      token: forceAuth._authToken || forceAuth.token,\n      username: forceAuth.username,\n      password: forceAuth._password || forceAuth.password,\n      auth: forceAuth._auth || forceAuth.auth,\n    })\n  }\n\n  // no auth for this URI, but might have it for the registry\n  if (!regKey) {\n    const registry = getRegistry(opts)\n    if (registry && uri !== registry && sameHost(uri, registry))\n      return getAuth(registry, opts)\n    else if (registry !== opts.registry) {\n      // If making a tarball request to a different base URI than the\n      // registry where we logged in, but the same auth SHOULD be sent\n      // to that artifact host, then we track where it was coming in from,\n      // and warn the user if we get a 4xx error on it.\n      const scopeAuthKey = regKeyFromURI(registry, opts)\n      return new Auth({ scopeAuthKey })\n    }\n  }\n\n  const {\n    [`${regKey}:_authToken`]: token,\n    [`${regKey}:username`]: username,\n    [`${regKey}:_password`]: password,\n    [`${regKey}:_auth`]: auth,\n  } = opts\n\n  return new Auth({\n    scopeAuthKey: null,\n    token,\n    auth,\n    username,\n    password,\n  })\n}\n\nclass Auth {\n  constructor ({ token, auth, username, password, scopeAuthKey }) {\n    this.scopeAuthKey = scopeAuthKey\n    this.token = null\n    this.auth = null\n    this.isBasicAuth = false\n    if (token)\n      this.token = token\n    else if (auth)\n      this.auth = auth\n    else if (username && password) {\n      const p = Buffer.from(password, 'base64').toString('utf8')\n      this.auth = Buffer.from(`${username}:${p}`, 'utf8').toString('base64')\n      this.isBasicAuth = true\n    }\n  }\n}\n\nmodule.exports = getAuth\n"]},"metadata":{},"sourceType":"script"}