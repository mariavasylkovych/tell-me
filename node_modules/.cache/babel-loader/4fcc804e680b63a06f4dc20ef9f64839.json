{"ast":null,"code":"'use strict';\n\nconst url = require('url');\n\nconst gitHosts = require('./git-host-info.js');\n\nconst GitHost = module.exports = require('./git-host.js');\n\nconst LRU = require('lru-cache');\n\nconst cache = new LRU({\n  max: 1000\n});\nconst protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n};\n\nfunction protocolToRepresentation(protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);\n}\n\nconst authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n};\nconst knownProtocols = Object.keys(gitHosts.byShortcut).concat(['http:', 'https:', 'git:', 'git+ssh:', 'git+https:', 'ssh:']);\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') {\n    return;\n  }\n\n  const key = giturl + JSON.stringify(opts || {});\n\n  if (!cache.has(key)) {\n    cache.set(key, fromUrl(giturl, opts));\n  }\n\n  return cache.get(key);\n};\n\nfunction fromUrl(giturl, opts) {\n  if (!giturl) {\n    return;\n  }\n\n  const url = isGitHubShorthand(giturl) ? 'github:' + giturl : correctProtocol(giturl);\n  const parsed = parseGitUrl(url);\n\n  if (!parsed) {\n    return parsed;\n  }\n\n  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];\n  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.') ? parsed.hostname.slice(4) : parsed.hostname];\n  const gitHostName = gitHostShortcut || gitHostDomain;\n\n  if (!gitHostName) {\n    return;\n  }\n\n  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];\n  let auth = null;\n\n  if (authProtocols[parsed.protocol] && (parsed.username || parsed.password)) {\n    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`;\n  }\n\n  let committish = null;\n  let user = null;\n  let project = null;\n  let defaultRepresentation = null;\n\n  try {\n    if (gitHostShortcut) {\n      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname;\n      const firstAt = pathname.indexOf('@'); // we ignore auth for shortcuts, so just trim it out\n\n      if (firstAt > -1) {\n        pathname = pathname.slice(firstAt + 1);\n      }\n\n      const lastSlash = pathname.lastIndexOf('/');\n\n      if (lastSlash > -1) {\n        user = decodeURIComponent(pathname.slice(0, lastSlash)); // we want nulls only, never empty strings\n\n        if (!user) {\n          user = null;\n        }\n\n        project = decodeURIComponent(pathname.slice(lastSlash + 1));\n      } else {\n        project = decodeURIComponent(pathname);\n      }\n\n      if (project.endsWith('.git')) {\n        project = project.slice(0, -4);\n      }\n\n      if (parsed.hash) {\n        committish = decodeURIComponent(parsed.hash.slice(1));\n      }\n\n      defaultRepresentation = 'shortcut';\n    } else {\n      if (!gitHostInfo.protocols.includes(parsed.protocol)) {\n        return;\n      }\n\n      const segments = gitHostInfo.extract(parsed);\n\n      if (!segments) {\n        return;\n      }\n\n      user = segments.user && decodeURIComponent(segments.user);\n      project = decodeURIComponent(segments.project);\n      committish = decodeURIComponent(segments.committish);\n      defaultRepresentation = protocolToRepresentation(parsed.protocol);\n    }\n  } catch (err) {\n    /* istanbul ignore else */\n    if (err instanceof URIError) {\n      return;\n    } else {\n      throw err;\n    }\n  }\n\n  return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);\n} // accepts input like git:github.com:user/repo and inserts the // after the first :\n\n\nconst correctProtocol = arg => {\n  const firstColon = arg.indexOf(':');\n  const proto = arg.slice(0, firstColon + 1);\n\n  if (knownProtocols.includes(proto)) {\n    return arg;\n  }\n\n  const firstAt = arg.indexOf('@');\n\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`;\n    } else {\n      return arg;\n    }\n  }\n\n  const doubleSlash = arg.indexOf('//');\n\n  if (doubleSlash === firstColon + 1) {\n    return arg;\n  }\n\n  return arg.slice(0, firstColon + 1) + '//' + arg.slice(firstColon + 1);\n}; // look for github shorthand inputs, such as npm/cli\n\n\nconst isGitHubShorthand = arg => {\n  // it cannot contain whitespace before the first #\n  // it cannot start with a / because that's probably an absolute file path\n  // but it must include a slash since repos are username/repository\n  // it cannot start with a . because that's probably a relative file path\n  // it cannot start with an @ because that's a scoped package if it passes the other tests\n  // it cannot contain a : before a # because that tells us that there's a protocol\n  // a second / may not exist before a #\n  const firstHash = arg.indexOf('#');\n  const firstSlash = arg.indexOf('/');\n  const secondSlash = arg.indexOf('/', firstSlash + 1);\n  const firstColon = arg.indexOf(':');\n  const firstSpace = /\\s/.exec(arg);\n  const firstAt = arg.indexOf('@');\n  const spaceOnlyAfterHash = !firstSpace || firstHash > -1 && firstSpace.index > firstHash;\n  const atOnlyAfterHash = firstAt === -1 || firstHash > -1 && firstAt > firstHash;\n  const colonOnlyAfterHash = firstColon === -1 || firstHash > -1 && firstColon > firstHash;\n  const secondSlashOnlyAfterHash = secondSlash === -1 || firstHash > -1 && secondSlash > firstHash;\n  const hasSlash = firstSlash > 0; // if a # is found, what we really want to know is that the character immediately before # is not a /\n\n  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/');\n  const doesNotStartWithDot = !arg.startsWith('.');\n  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash;\n}; // attempt to correct an scp style url so that it will parse with `new URL()`\n\n\nconst correctUrl = giturl => {\n  const firstAt = giturl.indexOf('@');\n  const lastHash = giturl.lastIndexOf('#');\n  let firstColon = giturl.indexOf(':');\n  let lastColon = giturl.lastIndexOf(':', lastHash > -1 ? lastHash : Infinity);\n  let corrected;\n\n  if (lastColon > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    corrected = giturl.slice(0, lastColon) + '/' + giturl.slice(lastColon + 1); // // and we find our new : positions\n\n    firstColon = corrected.indexOf(':');\n    lastColon = corrected.lastIndexOf(':');\n  }\n\n  if (firstColon === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    corrected = `git+ssh://${corrected}`;\n  }\n\n  return corrected;\n}; // try to parse the url as its given to us, if that throws\n// then we try to clean the url and parse that result instead\n// THIS FUNCTION SHOULD NEVER THROW\n\n\nconst parseGitUrl = giturl => {\n  let result;\n\n  try {\n    result = new url.URL(giturl);\n  } catch (err) {}\n\n  if (result) {\n    return result;\n  }\n\n  const correctedUrl = correctUrl(giturl);\n\n  try {\n    result = new url.URL(correctedUrl);\n  } catch (err) {}\n\n  return result;\n};","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/hosted-git-info/index.js"],"names":["url","require","gitHosts","GitHost","module","exports","LRU","cache","max","protocolToRepresentationMap","protocolToRepresentation","protocol","slice","authProtocols","knownProtocols","Object","keys","byShortcut","concat","fromUrl","giturl","opts","key","JSON","stringify","has","set","get","isGitHubShorthand","correctProtocol","parsed","parseGitUrl","gitHostShortcut","gitHostDomain","byDomain","hostname","startsWith","gitHostName","gitHostInfo","auth","username","password","committish","user","project","defaultRepresentation","pathname","firstAt","indexOf","lastSlash","lastIndexOf","decodeURIComponent","endsWith","hash","protocols","includes","segments","extract","err","URIError","arg","firstColon","proto","doubleSlash","firstHash","firstSlash","secondSlash","firstSpace","exec","spaceOnlyAfterHash","index","atOnlyAfterHash","colonOnlyAfterHash","secondSlashOnlyAfterHash","hasSlash","doesNotEndWithSlash","doesNotStartWithDot","correctUrl","lastHash","lastColon","Infinity","corrected","result","URL","correctedUrl"],"mappings":"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","sourcesContent":["'use strict'\nconst url = require('url')\nconst gitHosts = require('./git-host-info.js')\nconst GitHost = module.exports = require('./git-host.js')\nconst LRU = require('lru-cache')\nconst cache = new LRU({ max: 1000 })\n\nconst protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n}\n\nfunction protocolToRepresentation (protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1)\n}\n\nconst authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n}\n\nconst knownProtocols = Object.keys(gitHosts.byShortcut).concat(['http:', 'https:', 'git:', 'git+ssh:', 'git+https:', 'ssh:'])\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') {\n    return\n  }\n\n  const key = giturl + JSON.stringify(opts || {})\n\n  if (!cache.has(key)) {\n    cache.set(key, fromUrl(giturl, opts))\n  }\n\n  return cache.get(key)\n}\n\nfunction fromUrl (giturl, opts) {\n  if (!giturl) {\n    return\n  }\n\n  const url = isGitHubShorthand(giturl) ? 'github:' + giturl : correctProtocol(giturl)\n  const parsed = parseGitUrl(url)\n  if (!parsed) {\n    return parsed\n  }\n\n  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol]\n  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.') ? parsed.hostname.slice(4) : parsed.hostname]\n  const gitHostName = gitHostShortcut || gitHostDomain\n  if (!gitHostName) {\n    return\n  }\n\n  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain]\n  let auth = null\n  if (authProtocols[parsed.protocol] && (parsed.username || parsed.password)) {\n    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`\n  }\n\n  let committish = null\n  let user = null\n  let project = null\n  let defaultRepresentation = null\n\n  try {\n    if (gitHostShortcut) {\n      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname\n      const firstAt = pathname.indexOf('@')\n      // we ignore auth for shortcuts, so just trim it out\n      if (firstAt > -1) {\n        pathname = pathname.slice(firstAt + 1)\n      }\n\n      const lastSlash = pathname.lastIndexOf('/')\n      if (lastSlash > -1) {\n        user = decodeURIComponent(pathname.slice(0, lastSlash))\n        // we want nulls only, never empty strings\n        if (!user) {\n          user = null\n        }\n        project = decodeURIComponent(pathname.slice(lastSlash + 1))\n      } else {\n        project = decodeURIComponent(pathname)\n      }\n\n      if (project.endsWith('.git')) {\n        project = project.slice(0, -4)\n      }\n\n      if (parsed.hash) {\n        committish = decodeURIComponent(parsed.hash.slice(1))\n      }\n\n      defaultRepresentation = 'shortcut'\n    } else {\n      if (!gitHostInfo.protocols.includes(parsed.protocol)) {\n        return\n      }\n\n      const segments = gitHostInfo.extract(parsed)\n      if (!segments) {\n        return\n      }\n\n      user = segments.user && decodeURIComponent(segments.user)\n      project = decodeURIComponent(segments.project)\n      committish = decodeURIComponent(segments.committish)\n      defaultRepresentation = protocolToRepresentation(parsed.protocol)\n    }\n  } catch (err) {\n    /* istanbul ignore else */\n    if (err instanceof URIError) {\n      return\n    } else {\n      throw err\n    }\n  }\n\n  return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts)\n}\n\n// accepts input like git:github.com:user/repo and inserts the // after the first :\nconst correctProtocol = (arg) => {\n  const firstColon = arg.indexOf(':')\n  const proto = arg.slice(0, firstColon + 1)\n  if (knownProtocols.includes(proto)) {\n    return arg\n  }\n\n  const firstAt = arg.indexOf('@')\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`\n    } else {\n      return arg\n    }\n  }\n\n  const doubleSlash = arg.indexOf('//')\n  if (doubleSlash === firstColon + 1) {\n    return arg\n  }\n\n  return arg.slice(0, firstColon + 1) + '//' + arg.slice(firstColon + 1)\n}\n\n// look for github shorthand inputs, such as npm/cli\nconst isGitHubShorthand = (arg) => {\n  // it cannot contain whitespace before the first #\n  // it cannot start with a / because that's probably an absolute file path\n  // but it must include a slash since repos are username/repository\n  // it cannot start with a . because that's probably a relative file path\n  // it cannot start with an @ because that's a scoped package if it passes the other tests\n  // it cannot contain a : before a # because that tells us that there's a protocol\n  // a second / may not exist before a #\n  const firstHash = arg.indexOf('#')\n  const firstSlash = arg.indexOf('/')\n  const secondSlash = arg.indexOf('/', firstSlash + 1)\n  const firstColon = arg.indexOf(':')\n  const firstSpace = /\\s/.exec(arg)\n  const firstAt = arg.indexOf('@')\n\n  const spaceOnlyAfterHash = !firstSpace || (firstHash > -1 && firstSpace.index > firstHash)\n  const atOnlyAfterHash = firstAt === -1 || (firstHash > -1 && firstAt > firstHash)\n  const colonOnlyAfterHash = firstColon === -1 || (firstHash > -1 && firstColon > firstHash)\n  const secondSlashOnlyAfterHash = secondSlash === -1 || (firstHash > -1 && secondSlash > firstHash)\n  const hasSlash = firstSlash > 0\n  // if a # is found, what we really want to know is that the character immediately before # is not a /\n  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/')\n  const doesNotStartWithDot = !arg.startsWith('.')\n\n  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash\n}\n\n// attempt to correct an scp style url so that it will parse with `new URL()`\nconst correctUrl = (giturl) => {\n  const firstAt = giturl.indexOf('@')\n  const lastHash = giturl.lastIndexOf('#')\n  let firstColon = giturl.indexOf(':')\n  let lastColon = giturl.lastIndexOf(':', lastHash > -1 ? lastHash : Infinity)\n\n  let corrected\n  if (lastColon > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    corrected = giturl.slice(0, lastColon) + '/' + giturl.slice(lastColon + 1)\n    // // and we find our new : positions\n    firstColon = corrected.indexOf(':')\n    lastColon = corrected.lastIndexOf(':')\n  }\n\n  if (firstColon === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    corrected = `git+ssh://${corrected}`\n  }\n\n  return corrected\n}\n\n// try to parse the url as its given to us, if that throws\n// then we try to clean the url and parse that result instead\n// THIS FUNCTION SHOULD NEVER THROW\nconst parseGitUrl = (giturl) => {\n  let result\n  try {\n    result = new url.URL(giturl)\n  } catch (err) {}\n\n  if (result) {\n    return result\n  }\n\n  const correctedUrl = correctUrl(giturl)\n  try {\n    result = new url.URL(correctedUrl)\n  } catch (err) {}\n\n  return result\n}\n"]},"metadata":{},"sourceType":"script"}