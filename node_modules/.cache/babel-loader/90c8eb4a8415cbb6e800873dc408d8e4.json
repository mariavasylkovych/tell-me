{"ast":null,"code":"const {\n  dirname,\n  join,\n  resolve,\n  relative,\n  isAbsolute\n} = require('path');\n\nconst rimraf_ = require('rimraf');\n\nconst {\n  promisify\n} = require('util');\n\nconst {\n  access: access_,\n  accessSync,\n  copyFile: copyFile_,\n  copyFileSync,\n  unlink: unlink_,\n  unlinkSync,\n  readdir: readdir_,\n  readdirSync,\n  rename: rename_,\n  renameSync,\n  stat: stat_,\n  statSync,\n  lstat: lstat_,\n  lstatSync,\n  symlink: symlink_,\n  symlinkSync,\n  readlink: readlink_,\n  readlinkSync\n} = require('fs');\n\nconst access = promisify(access_);\nconst copyFile = promisify(copyFile_);\nconst unlink = promisify(unlink_);\nconst readdir = promisify(readdir_);\nconst rename = promisify(rename_);\nconst stat = promisify(stat_);\nconst lstat = promisify(lstat_);\nconst symlink = promisify(symlink_);\nconst readlink = promisify(readlink_);\nconst rimraf = promisify(rimraf_);\nconst rimrafSync = rimraf_.sync;\n\nconst mkdirp = require('mkdirp');\n\nconst pathExists = async path => {\n  try {\n    await access(path);\n    return true;\n  } catch (er) {\n    return er.code !== 'ENOENT';\n  }\n};\n\nconst pathExistsSync = path => {\n  try {\n    accessSync(path);\n    return true;\n  } catch (er) {\n    return er.code !== 'ENOENT';\n  }\n};\n\nconst moveFile = async function (source, destination) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let root = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  let symlinks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required');\n  }\n\n  options = {\n    overwrite: true,\n    ...options\n  };\n\n  if (!options.overwrite && (await pathExists(destination))) {\n    throw new Error(`The destination file exists: ${destination}`);\n  }\n\n  await mkdirp(dirname(destination));\n\n  try {\n    await rename(source, destination);\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = await lstat(source);\n\n      if (sourceStat.isDirectory()) {\n        const files = await readdir(source);\n        await Promise.all(files.map(file => moveFile(join(source, file), join(destination, file), options, false, symlinks)));\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({\n          source,\n          destination\n        });\n      } else {\n        await copyFile(source, destination);\n      }\n    } else {\n      throw error;\n    }\n  }\n\n  if (root) {\n    await Promise.all(symlinks.map(async _ref => {\n      let {\n        source,\n        destination\n      } = _ref;\n      let target = await readlink(source); // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination\n\n      if (isAbsolute(target)) target = resolve(destination, relative(source, target)); // try to determine what the actual file is so we can create the correct type of symlink in windows\n\n      let targetStat;\n\n      try {\n        targetStat = await stat(resolve(dirname(source), target));\n      } catch (err) {}\n\n      await symlink(target, destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file');\n    }));\n    await rimraf(source);\n  }\n};\n\nconst moveFileSync = function (source, destination) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let root = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  let symlinks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required');\n  }\n\n  options = {\n    overwrite: true,\n    ...options\n  };\n\n  if (!options.overwrite && pathExistsSync(destination)) {\n    throw new Error(`The destination file exists: ${destination}`);\n  }\n\n  mkdirp.sync(dirname(destination));\n\n  try {\n    renameSync(source, destination);\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = lstatSync(source);\n\n      if (sourceStat.isDirectory()) {\n        const files = readdirSync(source);\n\n        for (const file of files) {\n          moveFileSync(join(source, file), join(destination, file), options, false, symlinks);\n        }\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({\n          source,\n          destination\n        });\n      } else {\n        copyFileSync(source, destination);\n      }\n    } else {\n      throw error;\n    }\n  }\n\n  if (root) {\n    for (const {\n      source,\n      destination\n    } of symlinks) {\n      let target = readlinkSync(source); // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination\n\n      if (isAbsolute(target)) target = resolve(destination, relative(source, target)); // try to determine what the actual file is so we can create the correct type of symlink in windows\n\n      let targetStat;\n\n      try {\n        targetStat = statSync(resolve(dirname(source), target));\n      } catch (err) {}\n\n      symlinkSync(target, destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file');\n    }\n\n    rimrafSync(source);\n  }\n};\n\nmodule.exports = moveFile;\nmodule.exports.sync = moveFileSync;","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/@npmcli/move-file/index.js"],"names":["dirname","join","resolve","relative","isAbsolute","require","rimraf_","promisify","access","access_","accessSync","copyFile","copyFile_","copyFileSync","unlink","unlink_","unlinkSync","readdir","readdir_","readdirSync","rename","rename_","renameSync","stat","stat_","statSync","lstat","lstat_","lstatSync","symlink","symlink_","symlinkSync","readlink","readlink_","readlinkSync","rimraf","rimrafSync","sync","mkdirp","pathExists","path","er","code","pathExistsSync","moveFile","source","destination","options","root","symlinks","TypeError","overwrite","Error","error","sourceStat","isDirectory","files","Promise","all","map","file","isSymbolicLink","push","target","targetStat","err","moveFileSync","module","exports"],"mappings":"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","sourcesContent":["const { dirname, join, resolve, relative, isAbsolute } = require('path')\nconst rimraf_ = require('rimraf')\nconst { promisify } = require('util')\nconst {\n  access: access_,\n  accessSync,\n  copyFile: copyFile_,\n  copyFileSync,\n  unlink: unlink_,\n  unlinkSync,\n  readdir: readdir_,\n  readdirSync,\n  rename: rename_,\n  renameSync,\n  stat: stat_,\n  statSync,\n  lstat: lstat_,\n  lstatSync,\n  symlink: symlink_,\n  symlinkSync,\n  readlink: readlink_,\n  readlinkSync\n} = require('fs')\n\nconst access = promisify(access_)\nconst copyFile = promisify(copyFile_)\nconst unlink = promisify(unlink_)\nconst readdir = promisify(readdir_)\nconst rename = promisify(rename_)\nconst stat = promisify(stat_)\nconst lstat = promisify(lstat_)\nconst symlink = promisify(symlink_)\nconst readlink = promisify(readlink_)\nconst rimraf = promisify(rimraf_)\nconst rimrafSync = rimraf_.sync\n\nconst mkdirp = require('mkdirp')\n\nconst pathExists = async path => {\n  try {\n    await access(path)\n    return true\n  } catch (er) {\n    return er.code !== 'ENOENT'\n  }\n}\n\nconst pathExistsSync = path => {\n  try {\n    accessSync(path)\n    return true\n  } catch (er) {\n    return er.code !== 'ENOENT'\n  }\n}\n\nconst moveFile = async (source, destination, options = {}, root = true, symlinks = []) => {\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required')\n  }\n\n  options = {\n    overwrite: true,\n    ...options\n  }\n\n  if (!options.overwrite && await pathExists(destination)) {\n    throw new Error(`The destination file exists: ${destination}`)\n  }\n\n  await mkdirp(dirname(destination))\n\n  try {\n    await rename(source, destination)\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = await lstat(source)\n      if (sourceStat.isDirectory()) {\n        const files = await readdir(source)\n        await Promise.all(files.map((file) => moveFile(join(source, file), join(destination, file), options, false, symlinks)))\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({ source, destination })\n      } else {\n        await copyFile(source, destination)\n      }\n    } else {\n      throw error\n    }\n  }\n\n  if (root) {\n    await Promise.all(symlinks.map(async ({ source, destination }) => {\n      let target = await readlink(source)\n      // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination\n      if (isAbsolute(target))\n        target = resolve(destination, relative(source, target))\n      // try to determine what the actual file is so we can create the correct type of symlink in windows\n      let targetStat\n      try {\n        targetStat = await stat(resolve(dirname(source), target))\n      } catch (err) {}\n      await symlink(target, destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file')\n    }))\n    await rimraf(source)\n  }\n}\n\nconst moveFileSync = (source, destination, options = {}, root = true, symlinks = []) => {\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required')\n  }\n\n  options = {\n    overwrite: true,\n    ...options\n  }\n\n  if (!options.overwrite && pathExistsSync(destination)) {\n    throw new Error(`The destination file exists: ${destination}`)\n  }\n\n  mkdirp.sync(dirname(destination))\n\n  try {\n    renameSync(source, destination)\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = lstatSync(source)\n      if (sourceStat.isDirectory()) {\n        const files = readdirSync(source)\n        for (const file of files) {\n          moveFileSync(join(source, file), join(destination, file), options, false, symlinks)\n        }\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({ source, destination })\n      } else {\n        copyFileSync(source, destination)\n      }\n    } else {\n      throw error\n    }\n  }\n\n  if (root) {\n    for (const { source, destination } of symlinks) {\n      let target = readlinkSync(source)\n      // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination\n      if (isAbsolute(target))\n        target = resolve(destination, relative(source, target))\n      // try to determine what the actual file is so we can create the correct type of symlink in windows\n      let targetStat\n      try {\n        targetStat = statSync(resolve(dirname(source), target))\n      } catch (err) {}\n      symlinkSync(target, destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file')\n    }\n    rimrafSync(source)\n  }\n}\n\nmodule.exports = moveFile\nmodule.exports.sync = moveFileSync\n"]},"metadata":{},"sourceType":"script"}