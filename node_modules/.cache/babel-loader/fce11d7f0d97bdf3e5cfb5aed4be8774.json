{"ast":null,"code":"// turn an array of lines from `git ls-remote` into a thing\n// vaguely resembling a packument, where docs are a resolved ref\nconst semver = require('semver');\n\nmodule.exports = lines => finish(lines.reduce(linesToRevsReducer, {\n  versions: {},\n  'dist-tags': {},\n  refs: {},\n  shas: {}\n}));\n\nconst finish = revs => distTags(shaList(peelTags(revs))); // We can check out shallow clones on specific SHAs if we have a ref\n\n\nconst shaList = revs => {\n  Object.keys(revs.refs).forEach(ref => {\n    const doc = revs.refs[ref];\n\n    if (!revs.shas[doc.sha]) {\n      revs.shas[doc.sha] = [ref];\n    } else {\n      revs.shas[doc.sha].push(ref);\n    }\n  });\n  return revs;\n}; // Replace any tags with their ^{} counterparts, if those exist\n\n\nconst peelTags = revs => {\n  Object.keys(revs.refs).filter(ref => ref.endsWith('^{}')).forEach(ref => {\n    const peeled = revs.refs[ref];\n    const unpeeled = revs.refs[ref.replace(/\\^\\{\\}$/, '')];\n\n    if (unpeeled) {\n      unpeeled.sha = peeled.sha;\n      delete revs.refs[ref];\n    }\n  });\n  return revs;\n};\n\nconst distTags = revs => {\n  // not entirely sure what situations would result in an\n  // ichabod repo, but best to be careful in Sleepy Hollow anyway\n  const HEAD = revs.refs.HEAD ||\n  /* istanbul ignore next */\n  {};\n  const versions = Object.keys(revs.versions);\n  versions.forEach(v => {\n    // simulate a dist-tags with latest pointing at the\n    // 'latest' branch if one exists and is a version,\n    // or HEAD if not.\n    const ver = revs.versions[v];\n\n    if (revs.refs.latest && ver.sha === revs.refs.latest.sha) {\n      revs['dist-tags'].latest = v;\n    } else if (ver.sha === HEAD.sha) {\n      revs['dist-tags'].HEAD = v;\n\n      if (!revs.refs.latest) {\n        revs['dist-tags'].latest = v;\n      }\n    }\n  });\n  return revs;\n};\n\nconst refType = ref => {\n  if (ref.startsWith('refs/tags/')) {\n    return 'tag';\n  }\n\n  if (ref.startsWith('refs/heads/')) {\n    return 'branch';\n  }\n\n  if (ref.startsWith('refs/pull/')) {\n    return 'pull';\n  }\n\n  if (ref === 'HEAD') {\n    return 'head';\n  } // Could be anything, ignore for now\n\n  /* istanbul ignore next */\n\n\n  return 'other';\n}; // return the doc, or null if we should ignore it.\n\n\nconst lineToRevDoc = line => {\n  const split = line.trim().split(/\\s+/, 2);\n\n  if (split.length < 2) {\n    return null;\n  }\n\n  const sha = split[0].trim();\n  const rawRef = split[1].trim();\n  const type = refType(rawRef);\n\n  if (type === 'tag') {\n    // refs/tags/foo^{} is the 'peeled tag', ie the commit\n    // that is tagged by refs/tags/foo they resolve to the same\n    // content, just different objects in git's data structure.\n    // But, we care about the thing the tag POINTS to, not the tag\n    // object itself, so we only look at the peeled tag refs, and\n    // ignore the pointer.\n    // For now, though, we have to save both, because some tags\n    // don't have peels, if they were not annotated.\n    const ref = rawRef.substr('refs/tags/'.length);\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  }\n\n  if (type === 'branch') {\n    const ref = rawRef.substr('refs/heads/'.length);\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  }\n\n  if (type === 'pull') {\n    // NB: merged pull requests installable with #pull/123/merge\n    // for the merged pr, or #pull/123 for the PR head\n    const ref = rawRef.substr('refs/'.length).replace(/\\/head$/, '');\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  }\n\n  if (type === 'head') {\n    const ref = 'HEAD';\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  } // at this point, all we can do is leave the ref un-munged\n\n\n  return {\n    sha,\n    ref: rawRef,\n    rawRef,\n    type\n  };\n};\n\nconst linesToRevsReducer = (revs, line) => {\n  const doc = lineToRevDoc(line);\n\n  if (!doc) {\n    return revs;\n  }\n\n  revs.refs[doc.ref] = doc;\n  revs.refs[doc.rawRef] = doc;\n\n  if (doc.type === 'tag') {\n    // try to pull a semver value out of tags like `release-v1.2.3`\n    // which is a pretty common pattern.\n    const match = !doc.ref.endsWith('^{}') && doc.ref.match(/v?(\\d+\\.\\d+\\.\\d+(?:[-+].+)?)$/);\n\n    if (match && semver.valid(match[1], true)) {\n      revs.versions[semver.clean(match[1], true)] = doc;\n    }\n  }\n\n  return revs;\n};","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/@npmcli/git/lib/lines-to-revs.js"],"names":["semver","require","module","exports","lines","finish","reduce","linesToRevsReducer","versions","refs","shas","revs","distTags","shaList","peelTags","Object","keys","forEach","ref","doc","sha","push","filter","endsWith","peeled","unpeeled","replace","HEAD","v","ver","latest","refType","startsWith","lineToRevDoc","line","split","trim","length","rawRef","type","substr","match","valid","clean"],"mappings":"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","sourcesContent":["// turn an array of lines from `git ls-remote` into a thing\n// vaguely resembling a packument, where docs are a resolved ref\n\nconst semver = require('semver')\n\nmodule.exports = lines => finish(lines.reduce(linesToRevsReducer, {\n  versions: {},\n  'dist-tags': {},\n  refs: {},\n  shas: {}\n}))\n\nconst finish = revs => distTags(shaList(peelTags(revs)))\n\n// We can check out shallow clones on specific SHAs if we have a ref\nconst shaList = revs => {\n  Object.keys(revs.refs).forEach(ref => {\n    const doc = revs.refs[ref]\n    if (!revs.shas[doc.sha]) {\n      revs.shas[doc.sha] = [ref]\n    } else {\n      revs.shas[doc.sha].push(ref)\n    }\n  })\n  return revs\n}\n\n// Replace any tags with their ^{} counterparts, if those exist\nconst peelTags = revs => {\n  Object.keys(revs.refs).filter(ref => ref.endsWith('^{}')).forEach(ref => {\n    const peeled = revs.refs[ref]\n    const unpeeled = revs.refs[ref.replace(/\\^\\{\\}$/, '')]\n    if (unpeeled) {\n      unpeeled.sha = peeled.sha\n      delete revs.refs[ref]\n    }\n  })\n  return revs\n}\n\nconst distTags = revs => {\n  // not entirely sure what situations would result in an\n  // ichabod repo, but best to be careful in Sleepy Hollow anyway\n  const HEAD = revs.refs.HEAD || /* istanbul ignore next */ {}\n  const versions = Object.keys(revs.versions)\n  versions.forEach(v => {\n    // simulate a dist-tags with latest pointing at the\n    // 'latest' branch if one exists and is a version,\n    // or HEAD if not.\n    const ver = revs.versions[v]\n    if (revs.refs.latest && ver.sha === revs.refs.latest.sha) {\n      revs['dist-tags'].latest = v\n    } else if (ver.sha === HEAD.sha) {\n      revs['dist-tags'].HEAD = v\n      if (!revs.refs.latest) { revs['dist-tags'].latest = v }\n    }\n  })\n  return revs\n}\n\nconst refType = ref => {\n  if (ref.startsWith('refs/tags/')) {\n    return 'tag'\n  }\n  if (ref.startsWith('refs/heads/')) {\n    return 'branch'\n  }\n  if (ref.startsWith('refs/pull/')) {\n    return 'pull'\n  }\n  if (ref === 'HEAD') {\n    return 'head'\n  }\n  // Could be anything, ignore for now\n  /* istanbul ignore next */\n  return 'other'\n}\n\n// return the doc, or null if we should ignore it.\nconst lineToRevDoc = line => {\n  const split = line.trim().split(/\\s+/, 2)\n  if (split.length < 2) { return null }\n\n  const sha = split[0].trim()\n  const rawRef = split[1].trim()\n  const type = refType(rawRef)\n\n  if (type === 'tag') {\n    // refs/tags/foo^{} is the 'peeled tag', ie the commit\n    // that is tagged by refs/tags/foo they resolve to the same\n    // content, just different objects in git's data structure.\n    // But, we care about the thing the tag POINTS to, not the tag\n    // object itself, so we only look at the peeled tag refs, and\n    // ignore the pointer.\n    // For now, though, we have to save both, because some tags\n    // don't have peels, if they were not annotated.\n    const ref = rawRef.substr('refs/tags/'.length)\n    return { sha, ref, rawRef, type }\n  }\n\n  if (type === 'branch') {\n    const ref = rawRef.substr('refs/heads/'.length)\n    return { sha, ref, rawRef, type }\n  }\n\n  if (type === 'pull') {\n    // NB: merged pull requests installable with #pull/123/merge\n    // for the merged pr, or #pull/123 for the PR head\n    const ref = rawRef.substr('refs/'.length).replace(/\\/head$/, '')\n    return { sha, ref, rawRef, type }\n  }\n\n  if (type === 'head') {\n    const ref = 'HEAD'\n    return { sha, ref, rawRef, type }\n  }\n\n  // at this point, all we can do is leave the ref un-munged\n  return { sha, ref: rawRef, rawRef, type }\n}\n\nconst linesToRevsReducer = (revs, line) => {\n  const doc = lineToRevDoc(line)\n\n  if (!doc) { return revs }\n\n  revs.refs[doc.ref] = doc\n  revs.refs[doc.rawRef] = doc\n\n  if (doc.type === 'tag') {\n    // try to pull a semver value out of tags like `release-v1.2.3`\n    // which is a pretty common pattern.\n    const match = !doc.ref.endsWith('^{}') &&\n      doc.ref.match(/v?(\\d+\\.\\d+\\.\\d+(?:[-+].+)?)$/)\n    if (match && semver.valid(match[1], true)) {\n      revs.versions[semver.clean(match[1], true)] = doc\n    }\n  }\n\n  return revs\n}\n"]},"metadata":{},"sourceType":"script"}