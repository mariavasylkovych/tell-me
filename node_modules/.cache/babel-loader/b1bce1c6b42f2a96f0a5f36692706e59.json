{"ast":null,"code":"// Function to determine whether a path is in the package.bin set.\n// Used to prevent issues when people publish a package from a\n// windows machine, and then install with --no-bin-links.\n//\n// Note: this is not possible in remote or file fetchers, since\n// we don't have the manifest until AFTER we've unpacked.  But the\n// main use case is registry fetching with git a distant second,\n// so that's an acceptable edge case to not handle.\nconst binObj = (name, bin) => typeof bin === 'string' ? {\n  [name]: bin\n} : bin;\n\nconst hasBin = (pkg, path) => {\n  const bin = binObj(pkg.name, pkg.bin);\n  const p = path.replace(/^[^\\\\\\/]*\\//, '');\n\n  for (const [k, v] of Object.entries(bin)) {\n    if (v === p) return true;\n  }\n\n  return false;\n};\n\nmodule.exports = (pkg, path) => pkg && pkg.bin ? hasBin(pkg, path) : false;","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/pacote/lib/util/is-package-bin.js"],"names":["binObj","name","bin","hasBin","pkg","path","p","replace","k","v","Object","entries","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,MAAM,GAAG,CAACC,IAAD,EAAOC,GAAP,KACb,OAAOA,GAAP,KAAe,QAAf,GAA0B;AAAE,GAACD,IAAD,GAAQC;AAAV,CAA1B,GAA4CA,GAD9C;;AAGA,MAAMC,MAAM,GAAG,CAACC,GAAD,EAAMC,IAAN,KAAe;AAC5B,QAAMH,GAAG,GAAGF,MAAM,CAACI,GAAG,CAACH,IAAL,EAAWG,GAAG,CAACF,GAAf,CAAlB;AACA,QAAMI,CAAC,GAAGD,IAAI,CAACE,OAAL,CAAa,aAAb,EAA4B,EAA5B,CAAV;;AACA,OAAK,MAAM,CAACC,CAAD,EAAIC,CAAJ,CAAX,IAAqBC,MAAM,CAACC,OAAP,CAAeT,GAAf,CAArB,EAA0C;AACxC,QAAIO,CAAC,KAAKH,CAAV,EACE,OAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACD,CARD;;AAUAM,MAAM,CAACC,OAAP,GAAiB,CAACT,GAAD,EAAMC,IAAN,KACfD,GAAG,IAAIA,GAAG,CAACF,GAAX,GAAiBC,MAAM,CAACC,GAAD,EAAMC,IAAN,CAAvB,GAAqC,KADvC","sourcesContent":["// Function to determine whether a path is in the package.bin set.\n// Used to prevent issues when people publish a package from a\n// windows machine, and then install with --no-bin-links.\n//\n// Note: this is not possible in remote or file fetchers, since\n// we don't have the manifest until AFTER we've unpacked.  But the\n// main use case is registry fetching with git a distant second,\n// so that's an acceptable edge case to not handle.\n\nconst binObj = (name, bin) =>\n  typeof bin === 'string' ? { [name]: bin } : bin\n\nconst hasBin = (pkg, path) => {\n  const bin = binObj(pkg.name, pkg.bin)\n  const p = path.replace(/^[^\\\\\\/]*\\//, '')\n  for (const [k, v] of Object.entries(bin)) {\n    if (v === p)\n      return true\n  }\n  return false\n}\n\nmodule.exports = (pkg, path) =>\n  pkg && pkg.bin ? hasBin(pkg, path) : false\n"]},"metadata":{},"sourceType":"script"}