{"ast":null,"code":"const Fetcher = require('./fetcher.js');\n\nconst FileFetcher = require('./file.js');\n\nconst RemoteFetcher = require('./remote.js');\n\nconst DirFetcher = require('./dir.js');\n\nconst hashre = /^[a-f0-9]{40}$/;\n\nconst git = require('@npmcli/git');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst npa = require('npm-package-arg');\n\nconst url = require('url');\n\nconst Minipass = require('minipass');\n\nconst cacache = require('cacache');\n\nconst {\n  promisify\n} = require('util');\n\nconst readPackageJson = require('read-package-json-fast');\n\nconst npm = require('./util/npm.js');\n\nconst _resolvedFromRepo = Symbol('_resolvedFromRepo');\n\nconst _resolvedFromHosted = Symbol('_resolvedFromHosted');\n\nconst _resolvedFromClone = Symbol('_resolvedFromClone');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst _addGitSha = Symbol('_addGitSha');\n\nconst addGitSha = require('./util/add-git-sha.js');\n\nconst _clone = Symbol('_clone');\n\nconst _cloneHosted = Symbol('_cloneHosted');\n\nconst _cloneRepo = Symbol('_cloneRepo');\n\nconst _setResolvedWithSha = Symbol('_setResolvedWithSha');\n\nconst _prepareDir = Symbol('_prepareDir'); // get the repository url.\n// prefer https if there's auth, since ssh will drop that.\n// otherwise, prefer ssh if available (more secure).\n// We have to add the git+ back because npa suppresses it.\n\n\nconst repoUrl = (h, opts) => h.sshurl && !(h.https && h.auth) && addGitPlus(h.sshurl(opts)) || h.https && addGitPlus(h.https(opts)); // add git+ to the url, but only one time.\n\n\nconst addGitPlus = url => url && `git+${url}`.replace(/^(git\\+)+/, 'git+');\n\nclass GitFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts);\n    this.resolvedRef = null;\n    if (this.spec.hosted) this.from = this.spec.hosted.shortcut({\n      noCommittish: false\n    }); // shortcut: avoid full clone when we can go straight to the tgz\n    // if we have the full sha and it's a hosted git platform\n\n    if (this.spec.gitCommittish && hashre.test(this.spec.gitCommittish)) {\n      this.resolvedSha = this.spec.gitCommittish; // use hosted.tarball() when we shell to RemoteFetcher later\n\n      this.resolved = this.spec.hosted ? repoUrl(this.spec.hosted, {\n        noCommittish: false\n      }) : this.spec.rawSpec;\n    } else this.resolvedSha = '';\n  } // just exposed to make it easier to test all the combinations\n\n\n  static repoUrl(hosted, opts) {\n    return repoUrl(hosted, opts);\n  }\n\n  get types() {\n    return ['git'];\n  }\n\n  resolve() {\n    // likely a hosted git repo with a sha, so get the tarball url\n    // but in general, no reason to resolve() more than necessary!\n    if (this.resolved) return super.resolve(); // fetch the git repo and then look at the current hash\n\n    const h = this.spec.hosted; // try to use ssh, fall back to git.\n\n    return h ? this[_resolvedFromHosted](h) : this[_resolvedFromRepo](this.spec.fetchSpec);\n  } // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n\n\n  [_resolvedFromHosted](hosted) {\n    return this[_resolvedFromRepo](hosted.https && hosted.https()).catch(er => {\n      // Throw early since we know pathspec errors will fail again if retried\n      if (er instanceof git.errors.GitPathspecError) throw er;\n      const ssh = hosted.sshurl && hosted.sshurl(); // no fallthrough if we can't fall through or have https auth\n\n      if (!ssh || hosted.auth) throw er;\n      return this[_resolvedFromRepo](ssh);\n    });\n  }\n\n  [_resolvedFromRepo](gitRemote) {\n    // XXX make this a custom error class\n    if (!gitRemote) return Promise.reject(new Error(`No git url for ${this.spec}`));\n    const gitRange = this.spec.gitRange;\n    const name = this.spec.name;\n    return git.revs(gitRemote, this.opts).then(remoteRefs => {\n      return gitRange ? pickManifest({\n        versions: remoteRefs.versions,\n        'dist-tags': remoteRefs['dist-tags'],\n        name\n      }, gitRange, this.opts) : this.spec.gitCommittish ? remoteRefs.refs[this.spec.gitCommittish] || remoteRefs.refs[remoteRefs.shas[this.spec.gitCommittish]] : remoteRefs.refs.HEAD; // no git committish, get default head\n    }).then(revDoc => {\n      // the committish provided isn't in the rev list\n      // things like HEAD~3 or @yesterday can land here.\n      if (!revDoc || !revDoc.sha) return this[_resolvedFromClone]();\n      this.resolvedRef = revDoc;\n      this.resolvedSha = revDoc.sha;\n\n      this[_addGitSha](revDoc.sha);\n\n      return this.resolved;\n    });\n  }\n\n  [_setResolvedWithSha](withSha) {\n    // we haven't cloned, so a tgz download is still faster\n    // of course, if it's not a known host, we can't do that.\n    this.resolved = !this.spec.hosted ? withSha : repoUrl(npa(withSha).hosted, {\n      noCommittish: false\n    });\n  } // when we get the git sha, we affix it to our spec to build up\n  // either a git url with a hash, or a tarball download URL\n\n\n  [_addGitSha](sha) {\n    this[_setResolvedWithSha](addGitSha(this.spec, sha));\n  }\n\n  [_resolvedFromClone]() {\n    // do a full or shallow clone, then look at the HEAD\n    // kind of wasteful, but no other option, really\n    return this[_clone](dir => this.resolved);\n  }\n\n  [_prepareDir](dir) {\n    return readPackageJson(dir + '/package.json').then(mani => {\n      // no need if we aren't going to do any preparation.\n      const scripts = mani.scripts;\n      if (!scripts || !(scripts.postinstall || scripts.build || scripts.preinstall || scripts.install || scripts.prepare)) return; // to avoid cases where we have an cycle of git deps that depend\n      // on one another, we only ever do preparation for one instance\n      // of a given git dep along the chain of installations.\n      // Note that this does mean that a dependency MAY in theory end up\n      // trying to run its prepare script using a dependency that has not\n      // been properly prepared itself, but that edge case is smaller\n      // and less hazardous than a fork bomb of npm and git commands.\n\n      const noPrepare = !process.env._PACOTE_NO_PREPARE_ ? [] : process.env._PACOTE_NO_PREPARE_.split('\\n');\n\n      if (noPrepare.includes(this.resolved)) {\n        this.log.info('prepare', 'skip prepare, already seen', this.resolved);\n        return;\n      }\n\n      noPrepare.push(this.resolved); // the DirFetcher will do its own preparation to run the prepare scripts\n      // All we have to do is put the deps in place so that it can succeed.\n\n      return npm(this.npmBin, [].concat(this.npmInstallCmd).concat(this.npmCliConfig), dir, { ...process.env,\n        _PACOTE_NO_PREPARE_: noPrepare.join('\\n')\n      }, {\n        message: 'git dep preparation failed'\n      });\n    });\n  }\n\n  [_tarballFromResolved]() {\n    const stream = new Minipass();\n    stream.resolved = this.resolved;\n    stream.integrity = this.integrity;\n    stream.from = this.from; // check it out and then shell out to the DirFetcher tarball packer\n\n    this[_clone](dir => this[_prepareDir](dir).then(() => new Promise((res, rej) => {\n      const df = new DirFetcher(`file:${dir}`, { ...this.opts,\n        resolved: null,\n        integrity: null\n      });\n\n      const dirStream = df[_tarballFromResolved]();\n\n      dirStream.on('error', rej);\n      dirStream.on('end', res);\n      dirStream.pipe(stream);\n    }))).catch(\n    /* istanbul ignore next: very unlikely and hard to test */\n    er => stream.emit('error', er));\n\n    return stream;\n  } // clone a git repo into a temp folder (or fetch and unpack if possible)\n  // handler accepts a directory, and returns a promise that resolves\n  // when we're done with it, at which point, cacache deletes it\n  //\n  // TODO: after cloning, create a tarball of the folder, and add to the cache\n  // with cacache.put.stream(), using a key that's deterministic based on the\n  // spec and repo, so that we don't ever clone the same thing multiple times.\n\n\n  [_clone](handler) {\n    let tarballOk = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const o = {\n      tmpPrefix: 'git-clone'\n    };\n    const ref = this.resolvedSha || this.spec.gitCommittish;\n    const h = this.spec.hosted;\n    const resolved = this.resolved; // can be set manually to false to fall back to actual git clone\n\n    tarballOk = tarballOk && h && resolved === repoUrl(h, {\n      noCommittish: false\n    }) && h.tarball;\n    return cacache.tmp.withTmp(this.cache, o, tmp => {\n      // if we're resolved, and have a tarball url, shell out to RemoteFetcher\n      if (tarballOk) {\n        const nameat = this.spec.name ? `${this.spec.name}@` : '';\n        return new RemoteFetcher(h.tarball({\n          noCommittish: false\n        }), { ...this.opts,\n          allowGitIgnore: true,\n          pkgid: `git:${nameat}${this.resolved}`,\n          resolved: this.resolved,\n          integrity: null // it'll always be different, if we have one\n\n        }).extract(tmp).then(() => handler(tmp), er => {\n          // fall back to ssh download if tarball fails\n          if (er.constructor.name.match(/^Http/)) return this[_clone](handler, false);else throw er;\n        });\n      }\n\n      return (h ? this[_cloneHosted](ref, tmp) : this[_cloneRepo](this.spec.fetchSpec, ref, tmp)).then(sha => {\n        this.resolvedSha = sha;\n        if (!this.resolved) this[_addGitSha](sha);\n      }).then(() => handler(tmp));\n    });\n  } // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n\n\n  [_cloneHosted](ref, tmp) {\n    const hosted = this.spec.hosted;\n    return this[_cloneRepo](hosted.https({\n      noCommittish: true\n    }), ref, tmp).catch(er => {\n      // Throw early since we know pathspec errors will fail again if retried\n      if (er instanceof git.errors.GitPathspecError) throw er;\n      const ssh = hosted.sshurl && hosted.sshurl({\n        noCommittish: true\n      }); // no fallthrough if we can't fall through or have https auth\n\n      if (!ssh || hosted.auth) throw er;\n      return this[_cloneRepo](ssh, ref, tmp);\n    });\n  }\n\n  [_cloneRepo](repo, ref, tmp) {\n    const {\n      opts,\n      spec\n    } = this;\n    return git.clone(repo, ref, tmp, { ...opts,\n      spec\n    });\n  }\n\n  manifest() {\n    if (this.package) return Promise.resolve(this.package);\n    return this.spec.hosted && this.resolved ? FileFetcher.prototype.manifest.apply(this) : this[_clone](dir => readPackageJson(dir + '/package.json').then(mani => this.package = { ...mani,\n      _integrity: this.integrity && String(this.integrity),\n      _resolved: this.resolved,\n      _from: this.from\n    }));\n  }\n\n  packument() {\n    return FileFetcher.prototype.packument.apply(this);\n  }\n\n}\n\nmodule.exports = GitFetcher;","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/pacote/lib/git.js"],"names":["Fetcher","require","FileFetcher","RemoteFetcher","DirFetcher","hashre","git","pickManifest","npa","url","Minipass","cacache","promisify","readPackageJson","npm","_resolvedFromRepo","Symbol","_resolvedFromHosted","_resolvedFromClone","_tarballFromResolved","for","_addGitSha","addGitSha","_clone","_cloneHosted","_cloneRepo","_setResolvedWithSha","_prepareDir","repoUrl","h","opts","sshurl","https","auth","addGitPlus","replace","GitFetcher","constructor","spec","resolvedRef","hosted","from","shortcut","noCommittish","gitCommittish","test","resolvedSha","resolved","rawSpec","types","resolve","fetchSpec","catch","er","errors","GitPathspecError","ssh","gitRemote","Promise","reject","Error","gitRange","name","revs","then","remoteRefs","versions","refs","shas","HEAD","revDoc","sha","withSha","dir","mani","scripts","postinstall","build","preinstall","install","prepare","noPrepare","process","env","_PACOTE_NO_PREPARE_","split","includes","log","info","push","npmBin","concat","npmInstallCmd","npmCliConfig","join","message","stream","integrity","res","rej","df","dirStream","on","pipe","emit","handler","tarballOk","o","tmpPrefix","ref","tarball","tmp","withTmp","cache","nameat","allowGitIgnore","pkgid","extract","match","repo","clone","manifest","package","prototype","apply","_integrity","String","_resolved","_from","packument","module","exports"],"mappings":"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","sourcesContent":["const Fetcher = require('./fetcher.js')\nconst FileFetcher = require('./file.js')\nconst RemoteFetcher = require('./remote.js')\nconst DirFetcher = require('./dir.js')\nconst hashre = /^[a-f0-9]{40}$/\nconst git = require('@npmcli/git')\nconst pickManifest = require('npm-pick-manifest')\nconst npa = require('npm-package-arg')\nconst url = require('url')\nconst Minipass = require('minipass')\nconst cacache = require('cacache')\nconst { promisify } = require('util')\nconst readPackageJson = require('read-package-json-fast')\nconst npm = require('./util/npm.js')\n\nconst _resolvedFromRepo = Symbol('_resolvedFromRepo')\nconst _resolvedFromHosted = Symbol('_resolvedFromHosted')\nconst _resolvedFromClone = Symbol('_resolvedFromClone')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst _addGitSha = Symbol('_addGitSha')\nconst addGitSha = require('./util/add-git-sha.js')\nconst _clone = Symbol('_clone')\nconst _cloneHosted = Symbol('_cloneHosted')\nconst _cloneRepo = Symbol('_cloneRepo')\nconst _setResolvedWithSha = Symbol('_setResolvedWithSha')\nconst _prepareDir = Symbol('_prepareDir')\n\n// get the repository url.\n// prefer https if there's auth, since ssh will drop that.\n// otherwise, prefer ssh if available (more secure).\n// We have to add the git+ back because npa suppresses it.\nconst repoUrl = (h, opts) =>\n  h.sshurl && !(h.https && h.auth) && addGitPlus(h.sshurl(opts)) ||\n  h.https && addGitPlus(h.https(opts))\n\n// add git+ to the url, but only one time.\nconst addGitPlus = url => url && `git+${url}`.replace(/^(git\\+)+/, 'git+')\n\nclass GitFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n    this.resolvedRef = null\n    if (this.spec.hosted)\n      this.from = this.spec.hosted.shortcut({ noCommittish: false })\n\n    // shortcut: avoid full clone when we can go straight to the tgz\n    // if we have the full sha and it's a hosted git platform\n    if (this.spec.gitCommittish && hashre.test(this.spec.gitCommittish)) {\n      this.resolvedSha = this.spec.gitCommittish\n      // use hosted.tarball() when we shell to RemoteFetcher later\n      this.resolved = this.spec.hosted\n        ? repoUrl(this.spec.hosted, { noCommittish: false })\n        : this.spec.rawSpec\n    } else\n      this.resolvedSha = ''\n  }\n\n  // just exposed to make it easier to test all the combinations\n  static repoUrl (hosted, opts) {\n    return repoUrl(hosted, opts)\n  }\n\n  get types () {\n    return ['git']\n  }\n\n  resolve () {\n    // likely a hosted git repo with a sha, so get the tarball url\n    // but in general, no reason to resolve() more than necessary!\n    if (this.resolved)\n      return super.resolve()\n\n    // fetch the git repo and then look at the current hash\n    const h = this.spec.hosted\n    // try to use ssh, fall back to git.\n    return h ? this[_resolvedFromHosted](h)\n      : this[_resolvedFromRepo](this.spec.fetchSpec)\n  }\n\n  // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n  [_resolvedFromHosted] (hosted) {\n    return this[_resolvedFromRepo](hosted.https && hosted.https())\n      .catch(er => {\n        // Throw early since we know pathspec errors will fail again if retried\n        if (er instanceof git.errors.GitPathspecError)\n          throw er\n        const ssh = hosted.sshurl && hosted.sshurl()\n        // no fallthrough if we can't fall through or have https auth\n        if (!ssh || hosted.auth)\n          throw er\n        return this[_resolvedFromRepo](ssh)\n      })\n  }\n\n  [_resolvedFromRepo] (gitRemote) {\n    // XXX make this a custom error class\n    if (!gitRemote)\n      return Promise.reject(new Error(`No git url for ${this.spec}`))\n    const gitRange = this.spec.gitRange\n    const name = this.spec.name\n    return git.revs(gitRemote, this.opts).then(remoteRefs => {\n      return gitRange ? pickManifest({\n          versions: remoteRefs.versions,\n          'dist-tags': remoteRefs['dist-tags'],\n          name,\n        }, gitRange, this.opts)\n        : this.spec.gitCommittish ?\n          remoteRefs.refs[this.spec.gitCommittish] ||\n          remoteRefs.refs[remoteRefs.shas[this.spec.gitCommittish]]\n        : remoteRefs.refs.HEAD // no git committish, get default head\n    }).then(revDoc => {\n      // the committish provided isn't in the rev list\n      // things like HEAD~3 or @yesterday can land here.\n      if (!revDoc || !revDoc.sha)\n        return this[_resolvedFromClone]()\n\n      this.resolvedRef = revDoc\n      this.resolvedSha = revDoc.sha\n      this[_addGitSha](revDoc.sha)\n      return this.resolved\n    })\n  }\n\n  [_setResolvedWithSha] (withSha) {\n    // we haven't cloned, so a tgz download is still faster\n    // of course, if it's not a known host, we can't do that.\n    this.resolved = !this.spec.hosted ? withSha\n      : repoUrl(npa(withSha).hosted, { noCommittish: false })\n  }\n\n  // when we get the git sha, we affix it to our spec to build up\n  // either a git url with a hash, or a tarball download URL\n  [_addGitSha] (sha) {\n    this[_setResolvedWithSha](addGitSha(this.spec, sha))\n  }\n\n  [_resolvedFromClone] () {\n    // do a full or shallow clone, then look at the HEAD\n    // kind of wasteful, but no other option, really\n    return this[_clone](dir => this.resolved)\n  }\n\n  [_prepareDir] (dir) {\n    return readPackageJson(dir + '/package.json').then(mani => {\n      // no need if we aren't going to do any preparation.\n      const scripts = mani.scripts\n      if (!scripts || !(\n          scripts.postinstall ||\n          scripts.build ||\n          scripts.preinstall ||\n          scripts.install ||\n          scripts.prepare))\n        return\n\n      // to avoid cases where we have an cycle of git deps that depend\n      // on one another, we only ever do preparation for one instance\n      // of a given git dep along the chain of installations.\n      // Note that this does mean that a dependency MAY in theory end up\n      // trying to run its prepare script using a dependency that has not\n      // been properly prepared itself, but that edge case is smaller\n      // and less hazardous than a fork bomb of npm and git commands.\n      const noPrepare = !process.env._PACOTE_NO_PREPARE_ ? []\n        : process.env._PACOTE_NO_PREPARE_.split('\\n')\n      if (noPrepare.includes(this.resolved)) {\n        this.log.info('prepare', 'skip prepare, already seen', this.resolved)\n        return\n      }\n      noPrepare.push(this.resolved)\n\n      // the DirFetcher will do its own preparation to run the prepare scripts\n      // All we have to do is put the deps in place so that it can succeed.\n      return npm(\n        this.npmBin,\n        [].concat(this.npmInstallCmd).concat(this.npmCliConfig),\n        dir,\n        { ...process.env, _PACOTE_NO_PREPARE_: noPrepare.join('\\n') },\n        { message: 'git dep preparation failed' }\n      )\n    })\n  }\n\n  [_tarballFromResolved] () {\n    const stream = new Minipass()\n    stream.resolved = this.resolved\n    stream.integrity = this.integrity\n    stream.from = this.from\n\n    // check it out and then shell out to the DirFetcher tarball packer\n    this[_clone](dir => this[_prepareDir](dir)\n      .then(() => new Promise((res, rej) => {\n        const df = new DirFetcher(`file:${dir}`, {\n          ...this.opts,\n          resolved: null,\n          integrity: null,\n        })\n        const dirStream = df[_tarballFromResolved]()\n        dirStream.on('error', rej)\n        dirStream.on('end', res)\n        dirStream.pipe(stream)\n      }))).catch(\n        /* istanbul ignore next: very unlikely and hard to test */\n        er => stream.emit('error', er)\n      )\n    return stream\n  }\n\n  // clone a git repo into a temp folder (or fetch and unpack if possible)\n  // handler accepts a directory, and returns a promise that resolves\n  // when we're done with it, at which point, cacache deletes it\n  //\n  // TODO: after cloning, create a tarball of the folder, and add to the cache\n  // with cacache.put.stream(), using a key that's deterministic based on the\n  // spec and repo, so that we don't ever clone the same thing multiple times.\n  [_clone] (handler, tarballOk = true) {\n    const o = { tmpPrefix: 'git-clone' }\n    const ref = this.resolvedSha || this.spec.gitCommittish\n    const h = this.spec.hosted\n    const resolved = this.resolved\n\n    // can be set manually to false to fall back to actual git clone\n    tarballOk = tarballOk &&\n      h && resolved === repoUrl(h, { noCommittish: false }) && h.tarball\n\n    return cacache.tmp.withTmp(this.cache, o, tmp => {\n      // if we're resolved, and have a tarball url, shell out to RemoteFetcher\n      if (tarballOk) {\n        const nameat = this.spec.name ? `${this.spec.name}@` : ''\n        return new RemoteFetcher(h.tarball({ noCommittish: false }), {\n          ...this.opts,\n          allowGitIgnore: true,\n          pkgid: `git:${nameat}${this.resolved}`,\n          resolved: this.resolved,\n          integrity: null, // it'll always be different, if we have one\n        }).extract(tmp).then(() => handler(tmp), er => {\n          // fall back to ssh download if tarball fails\n          if (er.constructor.name.match(/^Http/))\n            return this[_clone](handler, false)\n          else\n            throw er\n        })\n      }\n\n      return (\n        h ? this[_cloneHosted](ref, tmp)\n        : this[_cloneRepo](this.spec.fetchSpec, ref, tmp)\n      ).then(sha => {\n        this.resolvedSha = sha\n        if (!this.resolved)\n          this[_addGitSha](sha)\n      })\n      .then(() => handler(tmp))\n    })\n  }\n\n  // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n  [_cloneHosted] (ref, tmp) {\n    const hosted = this.spec.hosted\n    return this[_cloneRepo](hosted.https({ noCommittish: true }), ref, tmp)\n      .catch(er => {\n        // Throw early since we know pathspec errors will fail again if retried\n        if (er instanceof git.errors.GitPathspecError)\n          throw er\n        const ssh = hosted.sshurl && hosted.sshurl({ noCommittish: true })\n        // no fallthrough if we can't fall through or have https auth\n        if (!ssh || hosted.auth)\n          throw er\n        return this[_cloneRepo](ssh, ref, tmp)\n      })\n  }\n\n  [_cloneRepo] (repo, ref, tmp) {\n    const { opts, spec } = this\n    return git.clone(repo, ref, tmp, { ...opts, spec })\n  }\n\n  manifest () {\n    if (this.package)\n      return Promise.resolve(this.package)\n\n    return this.spec.hosted && this.resolved\n      ? FileFetcher.prototype.manifest.apply(this)\n      : this[_clone](dir =>\n          readPackageJson(dir + '/package.json')\n            .then(mani => this.package = {\n              ...mani,\n              _integrity: this.integrity && String(this.integrity),\n              _resolved: this.resolved,\n              _from: this.from,\n            }))\n  }\n\n  packument () {\n    return FileFetcher.prototype.packument.apply(this)\n  }\n}\nmodule.exports = GitFetcher\n"]},"metadata":{},"sourceType":"script"}