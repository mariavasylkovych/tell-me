{"ast":null,"code":"'use strict';\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nconst validateName = name => {\n  name = `${name}`;\n  if (invalidTokenRegex.test(name) || name === '') throw new TypeError(`${name} is not a legal HTTP header name`);\n};\n\nconst validateValue = value => {\n  value = `${value}`;\n  if (invalidHeaderCharRegex.test(value)) throw new TypeError(`${value} is not a legal HTTP header value`);\n};\n\nconst find = (map, name) => {\n  name = name.toLowerCase();\n\n  for (const key in map) {\n    if (key.toLowerCase() === name) return key;\n  }\n\n  return undefined;\n};\n\nconst MAP = Symbol('map');\n\nclass Headers {\n  constructor() {\n    let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    this[MAP] = Object.create(null);\n\n    if (init instanceof Headers) {\n      const rawHeaders = init.raw();\n      const headerNames = Object.keys(rawHeaders);\n\n      for (const headerName of headerNames) {\n        for (const value of rawHeaders[headerName]) {\n          this.append(headerName, value);\n        }\n      }\n\n      return;\n    } // no-op\n\n\n    if (init === undefined || init === null) return;\n\n    if (typeof init === 'object') {\n      const method = init[Symbol.iterator];\n\n      if (method !== null && method !== undefined) {\n        if (typeof method !== 'function') throw new TypeError('Header pairs must be iterable'); // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n\n        const pairs = [];\n\n        for (const pair of init) {\n          if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') throw new TypeError('Each header pair must be iterable');\n          const arrPair = Array.from(pair);\n          if (arrPair.length !== 2) throw new TypeError('Each header pair must be a name/value tuple');\n          pairs.push(arrPair);\n        }\n\n        for (const pair of pairs) {\n          this.append(pair[0], pair[1]);\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (const key of Object.keys(init)) {\n          this.append(key, init[key]);\n        }\n      }\n    } else throw new TypeError('Provided initializer must be an object');\n  }\n\n  get(name) {\n    name = `${name}`;\n    validateName(name);\n    const key = find(this[MAP], name);\n    if (key === undefined) return null;\n    return this[MAP][key].join(', ');\n  }\n\n  forEach(callback) {\n    let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let pairs = getHeaders(this);\n\n    for (let i = 0; i < pairs.length; i++) {\n      const [name, value] = pairs[i];\n      callback.call(thisArg, value, name, this); // refresh in case the callback added more headers\n\n      pairs = getHeaders(this);\n    }\n  }\n\n  set(name, value) {\n    name = `${name}`;\n    value = `${value}`;\n    validateName(name);\n    validateValue(value);\n    const key = find(this[MAP], name);\n    this[MAP][key !== undefined ? key : name] = [value];\n  }\n\n  append(name, value) {\n    name = `${name}`;\n    value = `${value}`;\n    validateName(name);\n    validateValue(value);\n    const key = find(this[MAP], name);\n    if (key !== undefined) this[MAP][key].push(value);else this[MAP][name] = [value];\n  }\n\n  has(name) {\n    name = `${name}`;\n    validateName(name);\n    return find(this[MAP], name) !== undefined;\n  }\n\n  delete(name) {\n    name = `${name}`;\n    validateName(name);\n    const key = find(this[MAP], name);\n    if (key !== undefined) delete this[MAP][key];\n  }\n\n  raw() {\n    return this[MAP];\n  }\n\n  keys() {\n    return new HeadersIterator(this, 'key');\n  }\n\n  values() {\n    return new HeadersIterator(this, 'value');\n  }\n\n  [Symbol.iterator]() {\n    return new HeadersIterator(this, 'key+value');\n  }\n\n  entries() {\n    return new HeadersIterator(this, 'key+value');\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Headers';\n  }\n\n  static exportNodeCompatibleHeaders(headers) {\n    const obj = Object.assign(Object.create(null), headers[MAP]); // http.request() only supports string as Host header. This hack makes\n    // specifying custom Host header possible.\n\n    const hostHeaderKey = find(headers[MAP], 'Host');\n    if (hostHeaderKey !== undefined) obj[hostHeaderKey] = obj[hostHeaderKey][0];\n    return obj;\n  }\n\n  static createHeadersLenient(obj) {\n    const headers = new Headers();\n\n    for (const name of Object.keys(obj)) {\n      if (invalidTokenRegex.test(name)) continue;\n\n      if (Array.isArray(obj[name])) {\n        for (const val of obj[name]) {\n          if (invalidHeaderCharRegex.test(val)) continue;\n          if (headers[MAP][name] === undefined) headers[MAP][name] = [val];else headers[MAP][name].push(val);\n        }\n      } else if (!invalidHeaderCharRegex.test(obj[name])) headers[MAP][name] = [obj[name]];\n    }\n\n    return headers;\n  }\n\n}\n\nObject.defineProperties(Headers.prototype, {\n  get: {\n    enumerable: true\n  },\n  forEach: {\n    enumerable: true\n  },\n  set: {\n    enumerable: true\n  },\n  append: {\n    enumerable: true\n  },\n  has: {\n    enumerable: true\n  },\n  delete: {\n    enumerable: true\n  },\n  keys: {\n    enumerable: true\n  },\n  values: {\n    enumerable: true\n  },\n  entries: {\n    enumerable: true\n  }\n});\n\nconst getHeaders = function (headers) {\n  let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n  return Object.keys(headers[MAP]).sort().map(kind === 'key' ? k => k.toLowerCase() : kind === 'value' ? k => headers[MAP][k].join(', ') : k => [k.toLowerCase(), headers[MAP][k].join(', ')]);\n};\n\nconst INTERNAL = Symbol('internal');\n\nclass HeadersIterator {\n  constructor(target, kind) {\n    this[INTERNAL] = {\n      target,\n      kind,\n      index: 0\n    };\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'HeadersIterator';\n  }\n\n  next() {\n    /* istanbul ignore if: should be impossible */\n    if (!this || Object.getPrototypeOf(this) !== HeadersIterator.prototype) throw new TypeError('Value of `this` is not a HeadersIterator');\n    const {\n      target,\n      kind,\n      index\n    } = this[INTERNAL];\n    const values = getHeaders(target, kind);\n    const len = values.length;\n\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    this[INTERNAL].index++;\n    return {\n      value: values[index],\n      done: false\n    };\n  }\n\n} // manually extend because 'extends' requires a ctor\n\n\nObject.setPrototypeOf(HeadersIterator.prototype, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\nmodule.exports = Headers;","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/minipass-fetch/lib/headers.js"],"names":["invalidTokenRegex","invalidHeaderCharRegex","validateName","name","test","TypeError","validateValue","value","find","map","toLowerCase","key","undefined","MAP","Symbol","Headers","constructor","init","Object","create","rawHeaders","raw","headerNames","keys","headerName","append","method","iterator","pairs","pair","arrPair","Array","from","length","push","get","join","forEach","callback","thisArg","getHeaders","i","call","set","has","delete","HeadersIterator","values","entries","toStringTag","exportNodeCompatibleHeaders","headers","obj","assign","hostHeaderKey","createHeadersLenient","isArray","val","defineProperties","prototype","enumerable","kind","sort","k","INTERNAL","target","index","next","getPrototypeOf","len","done","setPrototypeOf","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/\n\nconst validateName = name => {\n  name = `${name}`\n  if (invalidTokenRegex.test(name) || name === '')\n    throw new TypeError(`${name} is not a legal HTTP header name`)\n}\n\nconst validateValue = value => {\n  value = `${value}`\n  if (invalidHeaderCharRegex.test(value))\n    throw new TypeError(`${value} is not a legal HTTP header value`)\n}\n\nconst find = (map, name) => {\n  name = name.toLowerCase()\n  for (const key in map) {\n    if (key.toLowerCase() === name)\n      return key\n  }\n  return undefined\n}\n\nconst MAP = Symbol('map')\nclass Headers {\n  constructor (init = undefined) {\n    this[MAP] = Object.create(null)\n    if (init instanceof Headers) {\n      const rawHeaders = init.raw()\n      const headerNames = Object.keys(rawHeaders)\n      for (const headerName of headerNames) {\n        for (const value of rawHeaders[headerName]) {\n          this.append(headerName, value)\n        }\n      }\n      return\n    }\n\n    // no-op\n    if (init === undefined || init === null)\n      return\n\n    if (typeof init === 'object') {\n      const method = init[Symbol.iterator]\n      if (method !== null && method !== undefined) {\n        if (typeof method !== 'function')\n          throw new TypeError('Header pairs must be iterable')\n\n        // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = []\n        for (const pair of init) {\n          if (typeof pair !== 'object' ||\n              typeof pair[Symbol.iterator] !== 'function')\n            throw new TypeError('Each header pair must be iterable')\n          const arrPair = Array.from(pair)\n          if (arrPair.length !== 2)\n            throw new TypeError('Each header pair must be a name/value tuple')\n          pairs.push(arrPair)\n        }\n\n        for (const pair of pairs) {\n          this.append(pair[0], pair[1])\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (const key of Object.keys(init)) {\n          this.append(key, init[key])\n        }\n      }\n    } else\n      throw new TypeError('Provided initializer must be an object')\n  }\n\n  get (name) {\n    name = `${name}`\n    validateName(name)\n    const key = find(this[MAP], name)\n    if (key === undefined)\n      return null\n\n    return this[MAP][key].join(', ')\n  }\n\n  forEach (callback, thisArg = undefined) {\n    let pairs = getHeaders(this)\n    for (let i = 0; i < pairs.length; i++) {\n      const [name, value] = pairs[i]\n      callback.call(thisArg, value, name, this)\n      // refresh in case the callback added more headers\n      pairs = getHeaders(this)\n    }\n  }\n\n  set (name, value) {\n    name = `${name}`\n    value = `${value}`\n    validateName(name)\n    validateValue(value)\n    const key = find(this[MAP], name)\n    this[MAP][key !== undefined ? key : name] = [value]\n  }\n\n  append (name, value) {\n    name = `${name}`\n    value = `${value}`\n    validateName(name)\n    validateValue(value)\n    const key = find(this[MAP], name)\n    if (key !== undefined)\n      this[MAP][key].push(value)\n    else\n      this[MAP][name] = [value]\n  }\n\n  has (name) {\n    name = `${name}`\n    validateName(name)\n    return find(this[MAP], name) !== undefined\n  }\n\n  delete (name) {\n    name = `${name}`\n    validateName(name)\n    const key = find(this[MAP], name)\n    if (key !== undefined)\n      delete this[MAP][key]\n  }\n\n  raw () {\n    return this[MAP]\n  }\n\n  keys () {\n    return new HeadersIterator(this, 'key')\n  }\n\n  values () {\n    return new HeadersIterator(this, 'value')\n  }\n\n  [Symbol.iterator]() {\n    return new HeadersIterator(this, 'key+value')\n  }\n\n  entries () {\n    return new HeadersIterator(this, 'key+value')\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Headers'\n  }\n\n  static exportNodeCompatibleHeaders (headers) {\n    const obj = Object.assign(Object.create(null), headers[MAP])\n\n    // http.request() only supports string as Host header. This hack makes\n    // specifying custom Host header possible.\n    const hostHeaderKey = find(headers[MAP], 'Host')\n    if (hostHeaderKey !== undefined)\n      obj[hostHeaderKey] = obj[hostHeaderKey][0]\n\n    return obj\n  }\n\n  static createHeadersLenient (obj) {\n    const headers = new Headers()\n    for (const name of Object.keys(obj)) {\n      if (invalidTokenRegex.test(name))\n        continue\n\n      if (Array.isArray(obj[name])) {\n        for (const val of obj[name]) {\n          if (invalidHeaderCharRegex.test(val))\n            continue\n\n          if (headers[MAP][name] === undefined)\n            headers[MAP][name] = [val]\n          else\n            headers[MAP][name].push(val)\n        }\n      } else if (!invalidHeaderCharRegex.test(obj[name]))\n        headers[MAP][name] = [obj[name]]\n    }\n    return headers\n  }\n}\n\nObject.defineProperties(Headers.prototype, {\n  get: { enumerable: true },\n  forEach: { enumerable: true },\n  set: { enumerable: true },\n  append: { enumerable: true },\n  has: { enumerable: true },\n  delete: { enumerable: true },\n  keys: { enumerable: true },\n  values: { enumerable: true },\n  entries: { enumerable: true },\n})\n\nconst getHeaders = (headers, kind = 'key+value') =>\n  Object.keys(headers[MAP]).sort().map(\n    kind === 'key' ? k => k.toLowerCase()\n    : kind === 'value' ? k => headers[MAP][k].join(', ')\n    : k => [k.toLowerCase(), headers[MAP][k].join(', ')]\n  )\n\nconst INTERNAL = Symbol('internal')\n\nclass HeadersIterator {\n  constructor (target, kind) {\n    this[INTERNAL] = {\n      target,\n      kind,\n      index: 0,\n    }\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'HeadersIterator'\n  }\n\n  next () {\n    /* istanbul ignore if: should be impossible */\n    if (!this || Object.getPrototypeOf(this) !== HeadersIterator.prototype)\n      throw new TypeError('Value of `this` is not a HeadersIterator')\n\n    const { target, kind, index } = this[INTERNAL]\n    const values = getHeaders(target, kind)\n    const len = values.length\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true,\n      }\n    }\n\n    this[INTERNAL].index++\n\n    return { value: values[index], done: false }\n  }\n}\n\n// manually extend because 'extends' requires a ctor\nObject.setPrototypeOf(HeadersIterator.prototype,\n  Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())))\n\nmodule.exports = Headers\n"]},"metadata":{},"sourceType":"script"}