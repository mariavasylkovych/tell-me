{"ast":null,"code":"const CacheSemantics = require('http-cache-semantics');\n\nconst Negotiator = require('negotiator');\n\nconst ssri = require('ssri'); // HACK: negotiator lazy loads several of its own modules\n// as a micro optimization. we need to be sure that they're\n// in memory as soon as possible at startup so that we do\n// not try to lazy load them after the directory has been\n// retired during a self update of the npm CLI, we do this\n// by calling all of the methods that trigger a lazy load\n// on a fake instance.\n\n\nconst preloadNegotiator = new Negotiator({\n  headers: {}\n});\npreloadNegotiator.charsets();\npreloadNegotiator.encodings();\npreloadNegotiator.languages();\npreloadNegotiator.mediaTypes(); // options passed to http-cache-semantics constructor\n\nconst policyOptions = {\n  shared: false,\n  ignoreCargoCult: true\n}; // a fake empty response, used when only testing the\n// request for storability\n\nconst emptyResponse = {\n  status: 200,\n  headers: {}\n}; // returns a plain object representation of the Request\n\nconst requestObject = request => {\n  const _obj = {\n    method: request.method,\n    url: request.url,\n    headers: {}\n  };\n  request.headers.forEach((value, key) => {\n    _obj.headers[key] = value;\n  });\n  return _obj;\n}; // returns a plain object representation of the Response\n\n\nconst responseObject = response => {\n  const _obj = {\n    status: response.status,\n    headers: {}\n  };\n  response.headers.forEach((value, key) => {\n    _obj.headers[key] = value;\n  });\n  return _obj;\n};\n\nclass CachePolicy {\n  constructor(_ref) {\n    let {\n      entry,\n      request,\n      response,\n      options\n    } = _ref;\n    this.entry = entry;\n    this.request = requestObject(request);\n    this.response = responseObject(response);\n    this.options = options;\n    this.policy = new CacheSemantics(this.request, this.response, policyOptions);\n\n    if (this.entry) {\n      // if we have an entry, copy the timestamp to the _responseTime\n      // this is necessary because the CacheSemantics constructor forces\n      // the value to Date.now() which means a policy created from a\n      // cache entry is likely to always identify itself as stale\n      this.policy._responseTime = this.entry.metadata.time;\n    }\n  } // static method to quickly determine if a request alone is storable\n\n\n  static storable(request, options) {\n    // no cachePath means no caching\n    if (!options.cachePath) return false; // user explicitly asked not to cache\n\n    if (options.cache === 'no-store') return false; // we only cache GET and HEAD requests\n\n    if (!['GET', 'HEAD'].includes(request.method)) return false; // otherwise, let http-cache-semantics make the decision\n    // based on the request's headers\n\n    const policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions);\n    return policy.storable();\n  } // returns true if the policy satisfies the request\n\n\n  satisfies(request) {\n    const _req = requestObject(request);\n\n    if (this.request.headers.host !== _req.headers.host) return false;\n    const negotiatorA = new Negotiator(this.request);\n    const negotiatorB = new Negotiator(_req);\n    if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes())) return false;\n    if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages())) return false;\n    if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings())) return false;\n    if (this.options.integrity) return ssri.parse(this.options.integrity).match(this.entry.integrity);\n    return true;\n  } // returns true if the request and response allow caching\n\n\n  storable() {\n    return this.policy.storable();\n  } // NOTE: this is a hack to avoid parsing the cache-control\n  // header ourselves, it returns true if the response's\n  // cache-control contains must-revalidate\n\n\n  get mustRevalidate() {\n    return !!this.policy._rescc['must-revalidate'];\n  } // returns true if the cached response requires revalidation\n  // for the given request\n\n\n  needsRevalidation(request) {\n    const _req = requestObject(request); // force method to GET because we only cache GETs\n    // but can serve a HEAD from a cached GET\n\n\n    _req.method = 'GET';\n    return !this.policy.satisfiesWithoutRevalidation(_req);\n  }\n\n  responseHeaders() {\n    return this.policy.responseHeaders();\n  } // returns a new object containing the appropriate headers\n  // to send a revalidation request\n\n\n  revalidationHeaders(request) {\n    const _req = requestObject(request);\n\n    return this.policy.revalidationHeaders(_req);\n  } // returns true if the request/response was revalidated\n  // successfully. returns false if a new response was received\n\n\n  revalidated(request, response) {\n    const _req = requestObject(request);\n\n    const _res = responseObject(response);\n\n    const policy = this.policy.revalidatedPolicy(_req, _res);\n    return !policy.modified;\n  }\n\n}\n\nmodule.exports = CachePolicy;","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/make-fetch-happen/lib/cache/policy.js"],"names":["CacheSemantics","require","Negotiator","ssri","preloadNegotiator","headers","charsets","encodings","languages","mediaTypes","policyOptions","shared","ignoreCargoCult","emptyResponse","status","requestObject","request","_obj","method","url","forEach","value","key","responseObject","response","CachePolicy","constructor","entry","options","policy","_responseTime","metadata","time","storable","cachePath","cache","includes","satisfies","_req","host","negotiatorA","negotiatorB","JSON","stringify","integrity","parse","match","mustRevalidate","_rescc","needsRevalidation","satisfiesWithoutRevalidation","responseHeaders","revalidationHeaders","revalidated","_res","revalidatedPolicy","modified","module","exports"],"mappings":"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","sourcesContent":["const CacheSemantics = require('http-cache-semantics')\nconst Negotiator = require('negotiator')\nconst ssri = require('ssri')\n\n// HACK: negotiator lazy loads several of its own modules\n// as a micro optimization. we need to be sure that they're\n// in memory as soon as possible at startup so that we do\n// not try to lazy load them after the directory has been\n// retired during a self update of the npm CLI, we do this\n// by calling all of the methods that trigger a lazy load\n// on a fake instance.\nconst preloadNegotiator = new Negotiator({ headers: {} })\npreloadNegotiator.charsets()\npreloadNegotiator.encodings()\npreloadNegotiator.languages()\npreloadNegotiator.mediaTypes()\n\n// options passed to http-cache-semantics constructor\nconst policyOptions = {\n  shared: false,\n  ignoreCargoCult: true,\n}\n\n// a fake empty response, used when only testing the\n// request for storability\nconst emptyResponse = { status: 200, headers: {} }\n\n// returns a plain object representation of the Request\nconst requestObject = (request) => {\n  const _obj = {\n    method: request.method,\n    url: request.url,\n    headers: {},\n  }\n\n  request.headers.forEach((value, key) => {\n    _obj.headers[key] = value\n  })\n\n  return _obj\n}\n\n// returns a plain object representation of the Response\nconst responseObject = (response) => {\n  const _obj = {\n    status: response.status,\n    headers: {},\n  }\n\n  response.headers.forEach((value, key) => {\n    _obj.headers[key] = value\n  })\n\n  return _obj\n}\n\nclass CachePolicy {\n  constructor ({ entry, request, response, options }) {\n    this.entry = entry\n    this.request = requestObject(request)\n    this.response = responseObject(response)\n    this.options = options\n    this.policy = new CacheSemantics(this.request, this.response, policyOptions)\n\n    if (this.entry) {\n      // if we have an entry, copy the timestamp to the _responseTime\n      // this is necessary because the CacheSemantics constructor forces\n      // the value to Date.now() which means a policy created from a\n      // cache entry is likely to always identify itself as stale\n      this.policy._responseTime = this.entry.metadata.time\n    }\n  }\n\n  // static method to quickly determine if a request alone is storable\n  static storable (request, options) {\n    // no cachePath means no caching\n    if (!options.cachePath)\n      return false\n\n    // user explicitly asked not to cache\n    if (options.cache === 'no-store')\n      return false\n\n    // we only cache GET and HEAD requests\n    if (!['GET', 'HEAD'].includes(request.method))\n      return false\n\n    // otherwise, let http-cache-semantics make the decision\n    // based on the request's headers\n    const policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions)\n    return policy.storable()\n  }\n\n  // returns true if the policy satisfies the request\n  satisfies (request) {\n    const _req = requestObject(request)\n    if (this.request.headers.host !== _req.headers.host)\n      return false\n\n    const negotiatorA = new Negotiator(this.request)\n    const negotiatorB = new Negotiator(_req)\n\n    if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes()))\n      return false\n\n    if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages()))\n      return false\n\n    if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings()))\n      return false\n\n    if (this.options.integrity)\n      return ssri.parse(this.options.integrity).match(this.entry.integrity)\n\n    return true\n  }\n\n  // returns true if the request and response allow caching\n  storable () {\n    return this.policy.storable()\n  }\n\n  // NOTE: this is a hack to avoid parsing the cache-control\n  // header ourselves, it returns true if the response's\n  // cache-control contains must-revalidate\n  get mustRevalidate () {\n    return !!this.policy._rescc['must-revalidate']\n  }\n\n  // returns true if the cached response requires revalidation\n  // for the given request\n  needsRevalidation (request) {\n    const _req = requestObject(request)\n    // force method to GET because we only cache GETs\n    // but can serve a HEAD from a cached GET\n    _req.method = 'GET'\n    return !this.policy.satisfiesWithoutRevalidation(_req)\n  }\n\n  responseHeaders () {\n    return this.policy.responseHeaders()\n  }\n\n  // returns a new object containing the appropriate headers\n  // to send a revalidation request\n  revalidationHeaders (request) {\n    const _req = requestObject(request)\n    return this.policy.revalidationHeaders(_req)\n  }\n\n  // returns true if the request/response was revalidated\n  // successfully. returns false if a new response was received\n  revalidated (request, response) {\n    const _req = requestObject(request)\n    const _res = responseObject(response)\n    const policy = this.policy.revalidatedPolicy(_req, _res)\n    return !policy.modified\n  }\n}\n\nmodule.exports = CachePolicy\n"]},"metadata":{},"sourceType":"script"}