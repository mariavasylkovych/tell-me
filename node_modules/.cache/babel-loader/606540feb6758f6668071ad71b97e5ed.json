{"ast":null,"code":"// print a banner telling the user to upgrade npm to latest\n// but not in CI, and not if we're doing that already.\n// Check daily for betas, and weekly otherwise.\nconst pacote = require('pacote');\n\nconst ciDetect = require('@npmcli/ci-detect');\n\nconst semver = require('semver');\n\nconst chalk = require('chalk');\n\nconst {\n  promisify\n} = require('util');\n\nconst stat = promisify(require('fs').stat);\nconst writeFile = promisify(require('fs').writeFile);\n\nconst {\n  resolve\n} = require('path');\n\nconst log = require('./log-shim.js');\n\nconst isGlobalNpmUpdate = npm => {\n  return npm.flatOptions.global && ['install', 'update'].includes(npm.command) && npm.argv.some(arg => /^npm(@|$)/.test(arg));\n}; // update check frequency\n\n\nconst DAILY = 1000 * 60 * 60 * 24;\nconst WEEKLY = DAILY * 7; // don't put it in the _cacache folder, just in npm's cache\n\nconst lastCheckedFile = npm => resolve(npm.flatOptions.cache, '../_update-notifier-last-checked');\n\nconst checkTimeout = async (npm, duration) => {\n  const t = new Date(Date.now() - duration);\n  const f = lastCheckedFile(npm); // if we don't have a file, then definitely check it.\n\n  const st = await stat(f).catch(() => ({\n    mtime: t - 1\n  }));\n  return t > st.mtime;\n};\n\nconst updateNotifier = async function (npm) {\n  let spec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'latest';\n\n  // never check for updates in CI, when updating npm already, or opted out\n  if (!npm.config.get('update-notifier') || isGlobalNpmUpdate(npm) || ciDetect()) {\n    return null;\n  } // if we're on a prerelease train, then updates are coming fast\n  // check for a new one daily.  otherwise, weekly.\n\n\n  const {\n    version\n  } = npm;\n  const current = semver.parse(version); // if we're on a beta train, always get the next beta\n\n  if (current.prerelease.length) {\n    spec = `^${version}`;\n  } // while on a beta train, get updates daily\n\n\n  const duration = spec !== 'latest' ? DAILY : WEEKLY; // if we've already checked within the specified duration, don't check again\n\n  if (!(await checkTimeout(npm, duration))) {\n    return null;\n  } // if they're currently using a prerelease, nudge to the next prerelease\n  // otherwise, nudge to latest.\n\n\n  const useColor = log.useColor();\n  const mani = await pacote.manifest(`npm@${spec}`, {\n    // always prefer latest, even if doing --tag=whatever on the cmd\n    defaultTag: 'latest',\n    ...npm.flatOptions\n  }).catch(() => null); // if pacote failed, give up\n\n  if (!mani) {\n    return null;\n  }\n\n  const latest = mani.version; // if the current version is *greater* than latest, we're on a 'next'\n  // and should get the updates from that release train.\n  // Note that this isn't another http request over the network, because\n  // the packument will be cached by pacote from previous request.\n\n  if (semver.gt(version, latest) && spec === 'latest') {\n    return updateNotifier(npm, `^${version}`);\n  } // if we already have something >= the desired spec, then we're done\n\n\n  if (semver.gte(version, latest)) {\n    return null;\n  } // ok!  notify the user about this update they should get.\n  // The message is saved for printing at process exit so it will not get\n  // lost in any other messages being printed as part of the command.\n\n\n  const update = semver.parse(mani.version);\n  const type = update.major !== current.major ? 'major' : update.minor !== current.minor ? 'minor' : update.patch !== current.patch ? 'patch' : 'prerelease';\n  const typec = !useColor ? type : type === 'major' ? chalk.red(type) : type === 'minor' ? chalk.yellow(type) : chalk.green(type);\n  const oldc = !useColor ? current : chalk.red(current);\n  const latestc = !useColor ? latest : chalk.green(latest);\n  const changelog = `https://github.com/npm/cli/releases/tag/v${latest}`;\n  const changelogc = !useColor ? `<${changelog}>` : chalk.cyan(changelog);\n  const cmd = `npm install -g npm@${latest}`;\n  const cmdc = !useColor ? `\\`${cmd}\\`` : chalk.green(cmd);\n  const message = `\\nNew ${typec} version of npm available! ` + `${oldc} -> ${latestc}\\n` + `Changelog: ${changelogc}\\n` + `Run ${cmdc} to update!\\n`;\n  return message;\n}; // only update the notification timeout if we actually finished checking\n\n\nmodule.exports = async npm => {\n  const notification = await updateNotifier(npm); // intentional.  do not await this.  it's a best-effort update.  if this\n  // fails, it's ok.  might be using /dev/null as the cache or something weird\n  // like that.\n\n  writeFile(lastCheckedFile(npm), '').catch(() => {});\n  npm.updateNotification = notification;\n};","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/lib/utils/update-notifier.js"],"names":["pacote","require","ciDetect","semver","chalk","promisify","stat","writeFile","resolve","log","isGlobalNpmUpdate","npm","flatOptions","global","includes","command","argv","some","arg","test","DAILY","WEEKLY","lastCheckedFile","cache","checkTimeout","duration","t","Date","now","f","st","catch","mtime","updateNotifier","spec","config","get","version","current","parse","prerelease","length","useColor","mani","manifest","defaultTag","latest","gt","gte","update","type","major","minor","patch","typec","red","yellow","green","oldc","latestc","changelog","changelogc","cyan","cmd","cmdc","message","module","exports","notification","updateNotification"],"mappings":"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","sourcesContent":["// print a banner telling the user to upgrade npm to latest\n// but not in CI, and not if we're doing that already.\n// Check daily for betas, and weekly otherwise.\n\nconst pacote = require('pacote')\nconst ciDetect = require('@npmcli/ci-detect')\nconst semver = require('semver')\nconst chalk = require('chalk')\nconst { promisify } = require('util')\nconst stat = promisify(require('fs').stat)\nconst writeFile = promisify(require('fs').writeFile)\nconst { resolve } = require('path')\nconst log = require('./log-shim.js')\n\nconst isGlobalNpmUpdate = npm => {\n  return npm.flatOptions.global &&\n    ['install', 'update'].includes(npm.command) &&\n    npm.argv.some(arg => /^npm(@|$)/.test(arg))\n}\n\n// update check frequency\nconst DAILY = 1000 * 60 * 60 * 24\nconst WEEKLY = DAILY * 7\n\n// don't put it in the _cacache folder, just in npm's cache\nconst lastCheckedFile = npm =>\n  resolve(npm.flatOptions.cache, '../_update-notifier-last-checked')\n\nconst checkTimeout = async (npm, duration) => {\n  const t = new Date(Date.now() - duration)\n  const f = lastCheckedFile(npm)\n  // if we don't have a file, then definitely check it.\n  const st = await stat(f).catch(() => ({ mtime: t - 1 }))\n  return t > st.mtime\n}\n\nconst updateNotifier = async (npm, spec = 'latest') => {\n  // never check for updates in CI, when updating npm already, or opted out\n  if (!npm.config.get('update-notifier') ||\n      isGlobalNpmUpdate(npm) ||\n      ciDetect()) {\n    return null\n  }\n\n  // if we're on a prerelease train, then updates are coming fast\n  // check for a new one daily.  otherwise, weekly.\n  const { version } = npm\n  const current = semver.parse(version)\n\n  // if we're on a beta train, always get the next beta\n  if (current.prerelease.length) {\n    spec = `^${version}`\n  }\n\n  // while on a beta train, get updates daily\n  const duration = spec !== 'latest' ? DAILY : WEEKLY\n\n  // if we've already checked within the specified duration, don't check again\n  if (!(await checkTimeout(npm, duration))) {\n    return null\n  }\n\n  // if they're currently using a prerelease, nudge to the next prerelease\n  // otherwise, nudge to latest.\n  const useColor = log.useColor()\n\n  const mani = await pacote.manifest(`npm@${spec}`, {\n    // always prefer latest, even if doing --tag=whatever on the cmd\n    defaultTag: 'latest',\n    ...npm.flatOptions,\n  }).catch(() => null)\n\n  // if pacote failed, give up\n  if (!mani) {\n    return null\n  }\n\n  const latest = mani.version\n\n  // if the current version is *greater* than latest, we're on a 'next'\n  // and should get the updates from that release train.\n  // Note that this isn't another http request over the network, because\n  // the packument will be cached by pacote from previous request.\n  if (semver.gt(version, latest) && spec === 'latest') {\n    return updateNotifier(npm, `^${version}`)\n  }\n\n  // if we already have something >= the desired spec, then we're done\n  if (semver.gte(version, latest)) {\n    return null\n  }\n\n  // ok!  notify the user about this update they should get.\n  // The message is saved for printing at process exit so it will not get\n  // lost in any other messages being printed as part of the command.\n  const update = semver.parse(mani.version)\n  const type = update.major !== current.major ? 'major'\n    : update.minor !== current.minor ? 'minor'\n    : update.patch !== current.patch ? 'patch'\n    : 'prerelease'\n  const typec = !useColor ? type\n    : type === 'major' ? chalk.red(type)\n    : type === 'minor' ? chalk.yellow(type)\n    : chalk.green(type)\n  const oldc = !useColor ? current : chalk.red(current)\n  const latestc = !useColor ? latest : chalk.green(latest)\n  const changelog = `https://github.com/npm/cli/releases/tag/v${latest}`\n  const changelogc = !useColor ? `<${changelog}>` : chalk.cyan(changelog)\n  const cmd = `npm install -g npm@${latest}`\n  const cmdc = !useColor ? `\\`${cmd}\\`` : chalk.green(cmd)\n  const message = `\\nNew ${typec} version of npm available! ` +\n    `${oldc} -> ${latestc}\\n` +\n    `Changelog: ${changelogc}\\n` +\n    `Run ${cmdc} to update!\\n`\n\n  return message\n}\n\n// only update the notification timeout if we actually finished checking\nmodule.exports = async npm => {\n  const notification = await updateNotifier(npm)\n  // intentional.  do not await this.  it's a best-effort update.  if this\n  // fails, it's ok.  might be using /dev/null as the cache or something weird\n  // like that.\n  writeFile(lastCheckedFile(npm), '').catch(() => {})\n  npm.updateNotification = notification\n}\n"]},"metadata":{},"sourceType":"script"}