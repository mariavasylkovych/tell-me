{"ast":null,"code":"'use strict';\n\nmodule.exports = npa;\nmodule.exports.resolve = resolve;\nmodule.exports.Result = Result;\n\nconst url = require('url');\n\nconst HostedGit = require('hosted-git-info');\n\nconst semver = require('semver');\n\nconst path = global.FAKE_WINDOWS ? require('path').win32 : require('path');\n\nconst validatePackageName = require('validate-npm-package-name');\n\nconst {\n  homedir\n} = require('os');\n\nconst isWindows = process.platform === 'win32' || global.FAKE_WINDOWS;\nconst hasSlashes = isWindows ? /\\\\|[/]/ : /[/]/;\nconst isURL = /^(?:git[+])?[a-z]+:/i;\nconst isGit = /^[^@]+@[^:.]+\\.[^:]+:.+$/i;\nconst isFilename = /[.](?:tgz|tar.gz|tar)$/i;\n\nfunction npa(arg, where) {\n  let name;\n  let spec;\n\n  if (typeof arg === 'object') {\n    if (arg instanceof Result && (!where || where === arg.where)) return arg;else if (arg.name && arg.rawSpec) return npa.resolve(arg.name, arg.rawSpec, where || arg.where);else return npa(arg.raw, where || arg.where);\n  }\n\n  const nameEndsAt = arg[0] === '@' ? arg.slice(1).indexOf('@') + 1 : arg.indexOf('@');\n  const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg;\n  if (isURL.test(arg)) spec = arg;else if (isGit.test(arg)) spec = `git+ssh://${arg}`;else if (namePart[0] !== '@' && (hasSlashes.test(namePart) || isFilename.test(namePart))) spec = arg;else if (nameEndsAt > 0) {\n    name = namePart;\n    spec = arg.slice(nameEndsAt + 1);\n  } else {\n    const valid = validatePackageName(arg);\n    if (valid.validForOldPackages) name = arg;else spec = arg;\n  }\n  return resolve(name, spec, where, arg);\n}\n\nconst isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;\n\nfunction resolve(name, spec, where, arg) {\n  const res = new Result({\n    raw: arg,\n    name: name,\n    rawSpec: spec,\n    fromArgument: arg != null\n  });\n  if (name) res.setName(name);\n  if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) return fromFile(res, where);else if (spec && /^npm:/i.test(spec)) return fromAlias(res, where);\n  const hosted = HostedGit.fromUrl(spec, {\n    noGitPlus: true,\n    noCommittish: true\n  });\n  if (hosted) return fromHostedGit(res, hosted);else if (spec && isURL.test(spec)) return fromURL(res);else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) return fromFile(res, where);else return fromRegistry(res);\n}\n\nfunction invalidPackageName(name, valid) {\n  const err = new Error(`Invalid package name \"${name}\": ${valid.errors.join('; ')}`);\n  err.code = 'EINVALIDPACKAGENAME';\n  return err;\n}\n\nfunction invalidTagName(name) {\n  const err = new Error(`Invalid tag name \"${name}\": Tags may not have any characters that encodeURIComponent encodes.`);\n  err.code = 'EINVALIDTAGNAME';\n  return err;\n}\n\nfunction Result(opts) {\n  this.type = opts.type;\n  this.registry = opts.registry;\n  this.where = opts.where;\n  if (opts.raw == null) this.raw = opts.name ? opts.name + '@' + opts.rawSpec : opts.rawSpec;else this.raw = opts.raw;\n  this.name = undefined;\n  this.escapedName = undefined;\n  this.scope = undefined;\n  this.rawSpec = opts.rawSpec == null ? '' : opts.rawSpec;\n  this.saveSpec = opts.saveSpec;\n  this.fetchSpec = opts.fetchSpec;\n  if (opts.name) this.setName(opts.name);\n  this.gitRange = opts.gitRange;\n  this.gitCommittish = opts.gitCommittish;\n  this.hosted = opts.hosted;\n}\n\nResult.prototype.setName = function (name) {\n  const valid = validatePackageName(name);\n  if (!valid.validForOldPackages) throw invalidPackageName(name, valid);\n  this.name = name;\n  this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined; // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar\n\n  this.escapedName = name.replace('/', '%2f');\n  return this;\n};\n\nResult.prototype.toString = function () {\n  const full = [];\n  if (this.name != null && this.name !== '') full.push(this.name);\n  const spec = this.saveSpec || this.fetchSpec || this.rawSpec;\n  if (spec != null && spec !== '') full.push(spec);\n  return full.length ? full.join('@') : this.raw;\n};\n\nResult.prototype.toJSON = function () {\n  const result = Object.assign({}, this);\n  delete result.hosted;\n  return result;\n};\n\nfunction setGitCommittish(res, committish) {\n  if (committish != null && committish.length >= 7 && committish.slice(0, 7) === 'semver:') {\n    res.gitRange = decodeURIComponent(committish.slice(7));\n    res.gitCommittish = null;\n  } else res.gitCommittish = committish === '' ? null : committish;\n\n  return res;\n}\n\nfunction fromFile(res, where) {\n  if (!where) where = process.cwd();\n  res.type = isFilename.test(res.rawSpec) ? 'file' : 'directory';\n  res.where = where; // always put the '/' on where when resolving urls, or else\n  // file:foo from /path/to/bar goes to /path/to/foo, when we want\n  // it to be /path/to/foo/bar\n\n  let specUrl;\n  let resolvedUrl;\n  const prefix = !/^file:/.test(res.rawSpec) ? 'file:' : '';\n  const rawWithPrefix = prefix + res.rawSpec;\n  let rawNoPrefix = rawWithPrefix.replace(/^file:/, '');\n\n  try {\n    resolvedUrl = new url.URL(rawWithPrefix, `file://${path.resolve(where)}/`);\n    specUrl = new url.URL(rawWithPrefix);\n  } catch (originalError) {\n    const er = new Error('Invalid file: URL, must comply with RFC 8909');\n    throw Object.assign(er, {\n      raw: res.rawSpec,\n      spec: res,\n      where,\n      originalError\n    });\n  } // environment switch for testing\n\n\n  if (process.env.NPM_PACKAGE_ARG_8909_STRICT !== '1') {\n    // XXX backwards compatibility lack of compliance with 8909\n    // Remove when we want a breaking change to come into RFC compliance.\n    if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n      const rawSpec = res.rawSpec.replace(/^file:\\/\\//, 'file:///');\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`);\n      specUrl = new url.URL(rawSpec);\n      rawNoPrefix = rawSpec.replace(/^file:/, '');\n    } // turn file:/../foo into file:../foo\n\n\n    if (/^\\/\\.\\.?(\\/|$)/.test(rawNoPrefix)) {\n      const rawSpec = res.rawSpec.replace(/^file:\\//, 'file:');\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`);\n      specUrl = new url.URL(rawSpec);\n      rawNoPrefix = rawSpec.replace(/^file:/, '');\n    } // XXX end 8909 violation backwards compatibility section\n\n  } // file:foo - relative url to ./foo\n  // file:/foo - absolute path /foo\n  // file:///foo - absolute path to /foo, no authority host\n  // file://localhost/foo - absolute path to /foo, on localhost\n  // file://foo - absolute path to / on foo host (error!)\n\n\n  if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n    const msg = `Invalid file: URL, must be absolute if // present`;\n    throw Object.assign(new Error(msg), {\n      raw: res.rawSpec,\n      parsed: resolvedUrl\n    });\n  } // turn /C:/blah into just C:/blah on windows\n\n\n  let specPath = decodeURIComponent(specUrl.pathname);\n  let resolvedPath = decodeURIComponent(resolvedUrl.pathname);\n\n  if (isWindows) {\n    specPath = specPath.replace(/^\\/+([a-z]:\\/)/i, '$1');\n    resolvedPath = resolvedPath.replace(/^\\/+([a-z]:\\/)/i, '$1');\n  } // replace ~ with homedir, but keep the ~ in the saveSpec\n  // otherwise, make it relative to where param\n\n\n  if (/^\\/~(\\/|$)/.test(specPath)) {\n    res.saveSpec = `file:${specPath.substr(1)}`;\n    resolvedPath = path.resolve(homedir(), specPath.substr(3));\n  } else if (!path.isAbsolute(rawNoPrefix)) res.saveSpec = `file:${path.relative(where, resolvedPath)}`;else res.saveSpec = `file:${path.resolve(resolvedPath)}`;\n\n  res.fetchSpec = path.resolve(where, resolvedPath);\n  return res;\n}\n\nfunction fromHostedGit(res, hosted) {\n  res.type = 'git';\n  res.hosted = hosted;\n  res.saveSpec = hosted.toString({\n    noGitPlus: false,\n    noCommittish: false\n  });\n  res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString();\n  return setGitCommittish(res, hosted.committish);\n}\n\nfunction unsupportedURLType(protocol, spec) {\n  const err = new Error(`Unsupported URL Type \"${protocol}\": ${spec}`);\n  err.code = 'EUNSUPPORTEDPROTOCOL';\n  return err;\n}\n\nfunction matchGitScp(spec) {\n  // git ssh specifiers are overloaded to also use scp-style git\n  // specifiers, so we have to parse those out and treat them special.\n  // They are NOT true URIs, so we can't hand them to `url.parse`.\n  //\n  // This regex looks for things that look like:\n  // git+ssh://git@my.custom.git.com:username/project.git#deadbeef\n  //\n  // ...and various combinations. The username in the beginning is *required*.\n  const matched = spec.match(/^git\\+ssh:\\/\\/([^:#]+:[^#]+(?:\\.git)?)(?:#(.*))?$/i);\n  return matched && !matched[1].match(/:[0-9]+\\/?.*$/i) && {\n    fetchSpec: matched[1],\n    gitCommittish: matched[2] == null ? null : matched[2]\n  };\n}\n\nfunction fromURL(res) {\n  // eslint-disable-next-line node/no-deprecated-api\n  const urlparse = url.parse(res.rawSpec);\n  res.saveSpec = res.rawSpec; // check the protocol, and then see if it's git or not\n\n  switch (urlparse.protocol) {\n    case 'git:':\n    case 'git+http:':\n    case 'git+https:':\n    case 'git+rsync:':\n    case 'git+ftp:':\n    case 'git+file:':\n    case 'git+ssh:':\n      {\n        res.type = 'git';\n        const match = urlparse.protocol === 'git+ssh:' ? matchGitScp(res.rawSpec) : null;\n\n        if (match) {\n          setGitCommittish(res, match.gitCommittish);\n          res.fetchSpec = match.fetchSpec;\n        } else {\n          setGitCommittish(res, urlparse.hash != null ? urlparse.hash.slice(1) : '');\n          urlparse.protocol = urlparse.protocol.replace(/^git[+]/, '');\n\n          if (urlparse.protocol === 'file:' && /^git\\+file:\\/\\/[a-z]:/i.test(res.rawSpec)) {\n            // keep the drive letter : on windows file paths\n            urlparse.host += ':';\n            urlparse.hostname += ':';\n          }\n\n          delete urlparse.hash;\n          res.fetchSpec = url.format(urlparse);\n        }\n\n        break;\n      }\n\n    case 'http:':\n    case 'https:':\n      res.type = 'remote';\n      res.fetchSpec = res.saveSpec;\n      break;\n\n    default:\n      throw unsupportedURLType(urlparse.protocol, res.rawSpec);\n  }\n\n  return res;\n}\n\nfunction fromAlias(res, where) {\n  const subSpec = npa(res.rawSpec.substr(4), where);\n  if (subSpec.type === 'alias') throw new Error('nested aliases not supported');\n  if (!subSpec.registry) throw new Error('aliases only work for registry deps');\n  res.subSpec = subSpec;\n  res.registry = true;\n  res.type = 'alias';\n  res.saveSpec = null;\n  res.fetchSpec = null;\n  return res;\n}\n\nfunction fromRegistry(res) {\n  res.registry = true;\n  const spec = res.rawSpec === '' ? 'latest' : res.rawSpec.trim(); // no save spec for registry components as we save based on the fetched\n  // version, not on the argument so this can't compute that.\n\n  res.saveSpec = null;\n  res.fetchSpec = spec;\n  const version = semver.valid(spec, true);\n  const range = semver.validRange(spec, true);\n  if (version) res.type = 'version';else if (range) res.type = 'range';else {\n    if (encodeURIComponent(spec) !== spec) throw invalidTagName(spec);\n    res.type = 'tag';\n  }\n  return res;\n}","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/npm-package-arg/npa.js"],"names":["module","exports","npa","resolve","Result","url","require","HostedGit","semver","path","global","FAKE_WINDOWS","win32","validatePackageName","homedir","isWindows","process","platform","hasSlashes","isURL","isGit","isFilename","arg","where","name","spec","rawSpec","raw","nameEndsAt","slice","indexOf","namePart","test","valid","validForOldPackages","isFilespec","res","fromArgument","setName","fromFile","fromAlias","hosted","fromUrl","noGitPlus","noCommittish","fromHostedGit","fromURL","fromRegistry","invalidPackageName","err","Error","errors","join","code","invalidTagName","opts","type","registry","undefined","escapedName","scope","saveSpec","fetchSpec","gitRange","gitCommittish","prototype","replace","toString","full","push","length","toJSON","result","Object","assign","setGitCommittish","committish","decodeURIComponent","cwd","specUrl","resolvedUrl","prefix","rawWithPrefix","rawNoPrefix","URL","originalError","er","env","NPM_PACKAGE_ARG_8909_STRICT","host","msg","parsed","specPath","pathname","resolvedPath","substr","isAbsolute","relative","getDefaultRepresentation","unsupportedURLType","protocol","matchGitScp","matched","match","urlparse","parse","hash","hostname","format","subSpec","trim","version","range","validRange","encodeURIComponent"],"mappings":"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","sourcesContent":["'use strict'\nmodule.exports = npa\nmodule.exports.resolve = resolve\nmodule.exports.Result = Result\n\nconst url = require('url')\nconst HostedGit = require('hosted-git-info')\nconst semver = require('semver')\nconst path = global.FAKE_WINDOWS ? require('path').win32 : require('path')\nconst validatePackageName = require('validate-npm-package-name')\nconst { homedir } = require('os')\n\nconst isWindows = process.platform === 'win32' || global.FAKE_WINDOWS\nconst hasSlashes = isWindows ? /\\\\|[/]/ : /[/]/\nconst isURL = /^(?:git[+])?[a-z]+:/i\nconst isGit = /^[^@]+@[^:.]+\\.[^:]+:.+$/i\nconst isFilename = /[.](?:tgz|tar.gz|tar)$/i\n\nfunction npa (arg, where) {\n  let name\n  let spec\n  if (typeof arg === 'object') {\n    if (arg instanceof Result && (!where || where === arg.where))\n      return arg\n    else if (arg.name && arg.rawSpec)\n      return npa.resolve(arg.name, arg.rawSpec, where || arg.where)\n    else\n      return npa(arg.raw, where || arg.where)\n  }\n  const nameEndsAt = arg[0] === '@' ? arg.slice(1).indexOf('@') + 1 : arg.indexOf('@')\n  const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg\n  if (isURL.test(arg))\n    spec = arg\n  else if (isGit.test(arg))\n    spec = `git+ssh://${arg}`\n  else if (namePart[0] !== '@' && (hasSlashes.test(namePart) || isFilename.test(namePart)))\n    spec = arg\n  else if (nameEndsAt > 0) {\n    name = namePart\n    spec = arg.slice(nameEndsAt + 1)\n  } else {\n    const valid = validatePackageName(arg)\n    if (valid.validForOldPackages)\n      name = arg\n    else\n      spec = arg\n  }\n  return resolve(name, spec, where, arg)\n}\n\nconst isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/\n\nfunction resolve (name, spec, where, arg) {\n  const res = new Result({\n    raw: arg,\n    name: name,\n    rawSpec: spec,\n    fromArgument: arg != null,\n  })\n\n  if (name)\n    res.setName(name)\n\n  if (spec && (isFilespec.test(spec) || /^file:/i.test(spec)))\n    return fromFile(res, where)\n  else if (spec && /^npm:/i.test(spec))\n    return fromAlias(res, where)\n\n  const hosted = HostedGit.fromUrl(spec, {\n    noGitPlus: true,\n    noCommittish: true,\n  })\n  if (hosted)\n    return fromHostedGit(res, hosted)\n  else if (spec && isURL.test(spec))\n    return fromURL(res)\n  else if (spec && (hasSlashes.test(spec) || isFilename.test(spec)))\n    return fromFile(res, where)\n  else\n    return fromRegistry(res)\n}\n\nfunction invalidPackageName (name, valid) {\n  const err = new Error(`Invalid package name \"${name}\": ${valid.errors.join('; ')}`)\n  err.code = 'EINVALIDPACKAGENAME'\n  return err\n}\nfunction invalidTagName (name) {\n  const err = new Error(`Invalid tag name \"${name}\": Tags may not have any characters that encodeURIComponent encodes.`)\n  err.code = 'EINVALIDTAGNAME'\n  return err\n}\n\nfunction Result (opts) {\n  this.type = opts.type\n  this.registry = opts.registry\n  this.where = opts.where\n  if (opts.raw == null)\n    this.raw = opts.name ? opts.name + '@' + opts.rawSpec : opts.rawSpec\n  else\n    this.raw = opts.raw\n\n  this.name = undefined\n  this.escapedName = undefined\n  this.scope = undefined\n  this.rawSpec = opts.rawSpec == null ? '' : opts.rawSpec\n  this.saveSpec = opts.saveSpec\n  this.fetchSpec = opts.fetchSpec\n  if (opts.name)\n    this.setName(opts.name)\n  this.gitRange = opts.gitRange\n  this.gitCommittish = opts.gitCommittish\n  this.hosted = opts.hosted\n}\n\nResult.prototype.setName = function (name) {\n  const valid = validatePackageName(name)\n  if (!valid.validForOldPackages)\n    throw invalidPackageName(name, valid)\n\n  this.name = name\n  this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined\n  // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar\n  this.escapedName = name.replace('/', '%2f')\n  return this\n}\n\nResult.prototype.toString = function () {\n  const full = []\n  if (this.name != null && this.name !== '')\n    full.push(this.name)\n  const spec = this.saveSpec || this.fetchSpec || this.rawSpec\n  if (spec != null && spec !== '')\n    full.push(spec)\n  return full.length ? full.join('@') : this.raw\n}\n\nResult.prototype.toJSON = function () {\n  const result = Object.assign({}, this)\n  delete result.hosted\n  return result\n}\n\nfunction setGitCommittish (res, committish) {\n  if (committish != null && committish.length >= 7 && committish.slice(0, 7) === 'semver:') {\n    res.gitRange = decodeURIComponent(committish.slice(7))\n    res.gitCommittish = null\n  } else\n    res.gitCommittish = committish === '' ? null : committish\n\n  return res\n}\n\nfunction fromFile (res, where) {\n  if (!where)\n    where = process.cwd()\n  res.type = isFilename.test(res.rawSpec) ? 'file' : 'directory'\n  res.where = where\n\n  // always put the '/' on where when resolving urls, or else\n  // file:foo from /path/to/bar goes to /path/to/foo, when we want\n  // it to be /path/to/foo/bar\n\n  let specUrl\n  let resolvedUrl\n  const prefix = (!/^file:/.test(res.rawSpec) ? 'file:' : '')\n  const rawWithPrefix = prefix + res.rawSpec\n  let rawNoPrefix = rawWithPrefix.replace(/^file:/, '')\n  try {\n    resolvedUrl = new url.URL(rawWithPrefix, `file://${path.resolve(where)}/`)\n    specUrl = new url.URL(rawWithPrefix)\n  } catch (originalError) {\n    const er = new Error('Invalid file: URL, must comply with RFC 8909')\n    throw Object.assign(er, {\n      raw: res.rawSpec,\n      spec: res,\n      where,\n      originalError,\n    })\n  }\n\n  // environment switch for testing\n  if (process.env.NPM_PACKAGE_ARG_8909_STRICT !== '1') {\n    // XXX backwards compatibility lack of compliance with 8909\n    // Remove when we want a breaking change to come into RFC compliance.\n    if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n      const rawSpec = res.rawSpec.replace(/^file:\\/\\//, 'file:///')\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`)\n      specUrl = new url.URL(rawSpec)\n      rawNoPrefix = rawSpec.replace(/^file:/, '')\n    }\n    // turn file:/../foo into file:../foo\n    if (/^\\/\\.\\.?(\\/|$)/.test(rawNoPrefix)) {\n      const rawSpec = res.rawSpec.replace(/^file:\\//, 'file:')\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`)\n      specUrl = new url.URL(rawSpec)\n      rawNoPrefix = rawSpec.replace(/^file:/, '')\n    }\n    // XXX end 8909 violation backwards compatibility section\n  }\n\n  // file:foo - relative url to ./foo\n  // file:/foo - absolute path /foo\n  // file:///foo - absolute path to /foo, no authority host\n  // file://localhost/foo - absolute path to /foo, on localhost\n  // file://foo - absolute path to / on foo host (error!)\n  if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n    const msg = `Invalid file: URL, must be absolute if // present`\n    throw Object.assign(new Error(msg), {\n      raw: res.rawSpec,\n      parsed: resolvedUrl,\n    })\n  }\n\n  // turn /C:/blah into just C:/blah on windows\n  let specPath = decodeURIComponent(specUrl.pathname)\n  let resolvedPath = decodeURIComponent(resolvedUrl.pathname)\n  if (isWindows) {\n    specPath = specPath.replace(/^\\/+([a-z]:\\/)/i, '$1')\n    resolvedPath = resolvedPath.replace(/^\\/+([a-z]:\\/)/i, '$1')\n  }\n\n  // replace ~ with homedir, but keep the ~ in the saveSpec\n  // otherwise, make it relative to where param\n  if (/^\\/~(\\/|$)/.test(specPath)) {\n    res.saveSpec = `file:${specPath.substr(1)}`\n    resolvedPath = path.resolve(homedir(), specPath.substr(3))\n  } else if (!path.isAbsolute(rawNoPrefix))\n    res.saveSpec = `file:${path.relative(where, resolvedPath)}`\n  else\n    res.saveSpec = `file:${path.resolve(resolvedPath)}`\n\n  res.fetchSpec = path.resolve(where, resolvedPath)\n  return res\n}\n\nfunction fromHostedGit (res, hosted) {\n  res.type = 'git'\n  res.hosted = hosted\n  res.saveSpec = hosted.toString({ noGitPlus: false, noCommittish: false })\n  res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString()\n  return setGitCommittish(res, hosted.committish)\n}\n\nfunction unsupportedURLType (protocol, spec) {\n  const err = new Error(`Unsupported URL Type \"${protocol}\": ${spec}`)\n  err.code = 'EUNSUPPORTEDPROTOCOL'\n  return err\n}\n\nfunction matchGitScp (spec) {\n  // git ssh specifiers are overloaded to also use scp-style git\n  // specifiers, so we have to parse those out and treat them special.\n  // They are NOT true URIs, so we can't hand them to `url.parse`.\n  //\n  // This regex looks for things that look like:\n  // git+ssh://git@my.custom.git.com:username/project.git#deadbeef\n  //\n  // ...and various combinations. The username in the beginning is *required*.\n  const matched = spec.match(/^git\\+ssh:\\/\\/([^:#]+:[^#]+(?:\\.git)?)(?:#(.*))?$/i)\n  return matched && !matched[1].match(/:[0-9]+\\/?.*$/i) && {\n    fetchSpec: matched[1],\n    gitCommittish: matched[2] == null ? null : matched[2],\n  }\n}\n\nfunction fromURL (res) {\n  // eslint-disable-next-line node/no-deprecated-api\n  const urlparse = url.parse(res.rawSpec)\n  res.saveSpec = res.rawSpec\n  // check the protocol, and then see if it's git or not\n  switch (urlparse.protocol) {\n    case 'git:':\n    case 'git+http:':\n    case 'git+https:':\n    case 'git+rsync:':\n    case 'git+ftp:':\n    case 'git+file:':\n    case 'git+ssh:': {\n      res.type = 'git'\n      const match = urlparse.protocol === 'git+ssh:' ? matchGitScp(res.rawSpec)\n        : null\n      if (match) {\n        setGitCommittish(res, match.gitCommittish)\n        res.fetchSpec = match.fetchSpec\n      } else {\n        setGitCommittish(res, urlparse.hash != null ? urlparse.hash.slice(1) : '')\n        urlparse.protocol = urlparse.protocol.replace(/^git[+]/, '')\n        if (urlparse.protocol === 'file:' && /^git\\+file:\\/\\/[a-z]:/i.test(res.rawSpec)) {\n          // keep the drive letter : on windows file paths\n          urlparse.host += ':'\n          urlparse.hostname += ':'\n        }\n        delete urlparse.hash\n        res.fetchSpec = url.format(urlparse)\n      }\n      break\n    }\n    case 'http:':\n    case 'https:':\n      res.type = 'remote'\n      res.fetchSpec = res.saveSpec\n      break\n\n    default:\n      throw unsupportedURLType(urlparse.protocol, res.rawSpec)\n  }\n\n  return res\n}\n\nfunction fromAlias (res, where) {\n  const subSpec = npa(res.rawSpec.substr(4), where)\n  if (subSpec.type === 'alias')\n    throw new Error('nested aliases not supported')\n\n  if (!subSpec.registry)\n    throw new Error('aliases only work for registry deps')\n\n  res.subSpec = subSpec\n  res.registry = true\n  res.type = 'alias'\n  res.saveSpec = null\n  res.fetchSpec = null\n  return res\n}\n\nfunction fromRegistry (res) {\n  res.registry = true\n  const spec = res.rawSpec === '' ? 'latest' : res.rawSpec.trim()\n  // no save spec for registry components as we save based on the fetched\n  // version, not on the argument so this can't compute that.\n  res.saveSpec = null\n  res.fetchSpec = spec\n  const version = semver.valid(spec, true)\n  const range = semver.validRange(spec, true)\n  if (version)\n    res.type = 'version'\n  else if (range)\n    res.type = 'range'\n  else {\n    if (encodeURIComponent(spec) !== spec)\n      throw invalidTagName(spec)\n\n    res.type = 'tag'\n  }\n  return res\n}\n"]},"metadata":{},"sourceType":"script"}