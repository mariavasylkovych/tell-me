{"ast":null,"code":"const {\n  dirname\n} = require('path');\n\nconst fileURLToPath = require('../common/file-url-to-path/index.js');\n\nconst fs = require('../fs.js');\n\nconst defaultOptions = {\n  mode: 0o777,\n  recursive: false\n};\n\nconst mkdir = async (path, opts) => {\n  const options = { ...defaultOptions,\n    ...opts\n  }; // if we're not in recursive mode, just call the real mkdir with the path and\n  // the mode option only\n\n  if (!options.recursive) {\n    return fs.mkdir(path, options.mode);\n  }\n\n  const makeDirectory = async (dir, mode) => {\n    // we can't use dirname directly since these functions support URL\n    // objects with the file: protocol as the path input, so first we get a\n    // string path, then we can call dirname on that\n    const parent = dir != null && dir.href && dir.origin ? dirname(fileURLToPath(dir)) : dirname(dir); // if the parent is the dir itself, try to create it. anything but EISDIR\n    // should be rethrown\n\n    if (parent === dir) {\n      try {\n        await fs.mkdir(dir, opts);\n      } catch (err) {\n        if (err.code !== 'EISDIR') {\n          throw err;\n        }\n      }\n\n      return undefined;\n    }\n\n    try {\n      await fs.mkdir(dir, mode);\n      return dir;\n    } catch (err) {\n      // ENOENT means the parent wasn't there, so create that\n      if (err.code === 'ENOENT') {\n        const made = await makeDirectory(parent, mode);\n        await makeDirectory(dir, mode); // return the shallowest path we created, i.e. the result of creating\n        // the parent\n\n        return made;\n      } // an EEXIST means there's already something there\n      // an EROFS means we have a read-only filesystem and can't create a dir\n      // any other error is fatal and we should give up now\n\n\n      if (err.code !== 'EEXIST' && err.code !== 'EROFS') {\n        throw err;\n      } // stat the directory, if the result is a directory, then we successfully\n      // created this one so return its path. otherwise, we reject with the\n      // original error by ignoring the error in the catch\n\n\n      try {\n        const stat = await fs.stat(dir);\n\n        if (stat.isDirectory()) {\n          // if it already existed, we didn't create anything so return\n          // undefined\n          return undefined;\n        }\n      } catch (_) {} // if the thing that's there isn't a directory, then just re-throw\n\n\n      throw err;\n    }\n  };\n\n  return makeDirectory(path, options.mode);\n};\n\nmodule.exports = mkdir;","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/@npmcli/fs/lib/mkdir/polyfill.js"],"names":["dirname","require","fileURLToPath","fs","defaultOptions","mode","recursive","mkdir","path","opts","options","makeDirectory","dir","parent","href","origin","err","code","undefined","made","stat","isDirectory","_","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAcC,OAAO,CAAC,MAAD,CAA3B;;AAEA,MAAMC,aAAa,GAAGD,OAAO,CAAC,qCAAD,CAA7B;;AACA,MAAME,EAAE,GAAGF,OAAO,CAAC,UAAD,CAAlB;;AAEA,MAAMG,cAAc,GAAG;AACrBC,EAAAA,IAAI,EAAE,KADe;AAErBC,EAAAA,SAAS,EAAE;AAFU,CAAvB;;AAKA,MAAMC,KAAK,GAAG,OAAOC,IAAP,EAAaC,IAAb,KAAsB;AAClC,QAAMC,OAAO,GAAG,EAAE,GAAGN,cAAL;AAAqB,OAAGK;AAAxB,GAAhB,CADkC,CAGlC;AACA;;AACA,MAAI,CAACC,OAAO,CAACJ,SAAb,EAAwB;AACtB,WAAOH,EAAE,CAACI,KAAH,CAASC,IAAT,EAAeE,OAAO,CAACL,IAAvB,CAAP;AACD;;AAED,QAAMM,aAAa,GAAG,OAAOC,GAAP,EAAYP,IAAZ,KAAqB;AACzC;AACA;AACA;AACA,UAAMQ,MAAM,GAAGD,GAAG,IAAI,IAAP,IAAeA,GAAG,CAACE,IAAnB,IAA2BF,GAAG,CAACG,MAA/B,GACXf,OAAO,CAACE,aAAa,CAACU,GAAD,CAAd,CADI,GAEXZ,OAAO,CAACY,GAAD,CAFX,CAJyC,CAQzC;AACA;;AACA,QAAIC,MAAM,KAAKD,GAAf,EAAoB;AAClB,UAAI;AACF,cAAMT,EAAE,CAACI,KAAH,CAASK,GAAT,EAAcH,IAAd,CAAN;AACD,OAFD,CAEE,OAAOO,GAAP,EAAY;AACZ,YAAIA,GAAG,CAACC,IAAJ,KAAa,QAAjB,EAA2B;AACzB,gBAAMD,GAAN;AACD;AACF;;AACD,aAAOE,SAAP;AACD;;AAED,QAAI;AACF,YAAMf,EAAE,CAACI,KAAH,CAASK,GAAT,EAAcP,IAAd,CAAN;AACA,aAAOO,GAAP;AACD,KAHD,CAGE,OAAOI,GAAP,EAAY;AACZ;AACA,UAAIA,GAAG,CAACC,IAAJ,KAAa,QAAjB,EAA2B;AACzB,cAAME,IAAI,GAAG,MAAMR,aAAa,CAACE,MAAD,EAASR,IAAT,CAAhC;AACA,cAAMM,aAAa,CAACC,GAAD,EAAMP,IAAN,CAAnB,CAFyB,CAGzB;AACA;;AACA,eAAOc,IAAP;AACD,OARW,CAUZ;AACA;AACA;;;AACA,UAAIH,GAAG,CAACC,IAAJ,KAAa,QAAb,IAAyBD,GAAG,CAACC,IAAJ,KAAa,OAA1C,EAAmD;AACjD,cAAMD,GAAN;AACD,OAfW,CAiBZ;AACA;AACA;;;AACA,UAAI;AACF,cAAMI,IAAI,GAAG,MAAMjB,EAAE,CAACiB,IAAH,CAAQR,GAAR,CAAnB;;AACA,YAAIQ,IAAI,CAACC,WAAL,EAAJ,EAAwB;AACtB;AACA;AACA,iBAAOH,SAAP;AACD;AACF,OAPD,CAOE,OAAOI,CAAP,EAAU,CAAE,CA3BF,CA6BZ;;;AACA,YAAMN,GAAN;AACD;AACF,GAxDD;;AA0DA,SAAOL,aAAa,CAACH,IAAD,EAAOE,OAAO,CAACL,IAAf,CAApB;AACD,CApED;;AAsEAkB,MAAM,CAACC,OAAP,GAAiBjB,KAAjB","sourcesContent":["const { dirname } = require('path')\n\nconst fileURLToPath = require('../common/file-url-to-path/index.js')\nconst fs = require('../fs.js')\n\nconst defaultOptions = {\n  mode: 0o777,\n  recursive: false,\n}\n\nconst mkdir = async (path, opts) => {\n  const options = { ...defaultOptions, ...opts }\n\n  // if we're not in recursive mode, just call the real mkdir with the path and\n  // the mode option only\n  if (!options.recursive) {\n    return fs.mkdir(path, options.mode)\n  }\n\n  const makeDirectory = async (dir, mode) => {\n    // we can't use dirname directly since these functions support URL\n    // objects with the file: protocol as the path input, so first we get a\n    // string path, then we can call dirname on that\n    const parent = dir != null && dir.href && dir.origin\n      ? dirname(fileURLToPath(dir))\n      : dirname(dir)\n\n    // if the parent is the dir itself, try to create it. anything but EISDIR\n    // should be rethrown\n    if (parent === dir) {\n      try {\n        await fs.mkdir(dir, opts)\n      } catch (err) {\n        if (err.code !== 'EISDIR') {\n          throw err\n        }\n      }\n      return undefined\n    }\n\n    try {\n      await fs.mkdir(dir, mode)\n      return dir\n    } catch (err) {\n      // ENOENT means the parent wasn't there, so create that\n      if (err.code === 'ENOENT') {\n        const made = await makeDirectory(parent, mode)\n        await makeDirectory(dir, mode)\n        // return the shallowest path we created, i.e. the result of creating\n        // the parent\n        return made\n      }\n\n      // an EEXIST means there's already something there\n      // an EROFS means we have a read-only filesystem and can't create a dir\n      // any other error is fatal and we should give up now\n      if (err.code !== 'EEXIST' && err.code !== 'EROFS') {\n        throw err\n      }\n\n      // stat the directory, if the result is a directory, then we successfully\n      // created this one so return its path. otherwise, we reject with the\n      // original error by ignoring the error in the catch\n      try {\n        const stat = await fs.stat(dir)\n        if (stat.isDirectory()) {\n          // if it already existed, we didn't create anything so return\n          // undefined\n          return undefined\n        }\n      } catch (_) {}\n\n      // if the thing that's there isn't a directory, then just re-throw\n      throw err\n    }\n  }\n\n  return makeDirectory(path, options.mode)\n}\n\nmodule.exports = mkdir\n"]},"metadata":{},"sourceType":"script"}