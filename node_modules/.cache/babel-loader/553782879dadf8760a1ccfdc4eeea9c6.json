{"ast":null,"code":"'use strict';\n\nconst Collect = require('minipass-collect');\n\nconst Minipass = require('minipass');\n\nconst Pipeline = require('minipass-pipeline');\n\nconst fs = require('fs');\n\nconst util = require('util');\n\nconst index = require('./lib/entry-index');\n\nconst memo = require('./lib/memoization');\n\nconst read = require('./lib/content/read');\n\nconst writeFile = util.promisify(fs.writeFile);\n\nfunction getData(cache, key) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    integrity,\n    memoize,\n    size\n  } = opts;\n  const memoized = memo.get(cache, key, opts);\n\n  if (memoized && memoize !== false) {\n    return Promise.resolve({\n      metadata: memoized.entry.metadata,\n      data: memoized.data,\n      integrity: memoized.entry.integrity,\n      size: memoized.entry.size\n    });\n  }\n\n  return index.find(cache, key, opts).then(entry => {\n    if (!entry) throw new index.NotFoundError(cache, key);\n    return read(cache, entry.integrity, {\n      integrity,\n      size\n    }).then(data => {\n      if (memoize) memo.put(cache, entry, data, opts);\n      return {\n        data,\n        metadata: entry.metadata,\n        size: entry.size,\n        integrity: entry.integrity\n      };\n    });\n  });\n}\n\nmodule.exports = getData;\n\nfunction getDataByDigest(cache, key) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    integrity,\n    memoize,\n    size\n  } = opts;\n  const memoized = memo.get.byDigest(cache, key, opts);\n  if (memoized && memoize !== false) return Promise.resolve(memoized);\n  return read(cache, key, {\n    integrity,\n    size\n  }).then(res => {\n    if (memoize) memo.put.byDigest(cache, key, res, opts);\n    return res;\n  });\n}\n\nmodule.exports.byDigest = getDataByDigest;\n\nfunction getDataSync(cache, key) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    integrity,\n    memoize,\n    size\n  } = opts;\n  const memoized = memo.get(cache, key, opts);\n\n  if (memoized && memoize !== false) {\n    return {\n      metadata: memoized.entry.metadata,\n      data: memoized.data,\n      integrity: memoized.entry.integrity,\n      size: memoized.entry.size\n    };\n  }\n\n  const entry = index.find.sync(cache, key, opts);\n  if (!entry) throw new index.NotFoundError(cache, key);\n  const data = read.sync(cache, entry.integrity, {\n    integrity: integrity,\n    size: size\n  });\n  const res = {\n    metadata: entry.metadata,\n    data: data,\n    size: entry.size,\n    integrity: entry.integrity\n  };\n  if (memoize) memo.put(cache, entry, res.data, opts);\n  return res;\n}\n\nmodule.exports.sync = getDataSync;\n\nfunction getDataByDigestSync(cache, digest) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    integrity,\n    memoize,\n    size\n  } = opts;\n  const memoized = memo.get.byDigest(cache, digest, opts);\n  if (memoized && memoize !== false) return memoized;\n  const res = read.sync(cache, digest, {\n    integrity: integrity,\n    size: size\n  });\n  if (memoize) memo.put.byDigest(cache, digest, res, opts);\n  return res;\n}\n\nmodule.exports.sync.byDigest = getDataByDigestSync;\n\nconst getMemoizedStream = memoized => {\n  const stream = new Minipass();\n  stream.on('newListener', function (ev, cb) {\n    ev === 'metadata' && cb(memoized.entry.metadata);\n    ev === 'integrity' && cb(memoized.entry.integrity);\n    ev === 'size' && cb(memoized.entry.size);\n  });\n  stream.end(memoized.data);\n  return stream;\n};\n\nfunction getStream(cache, key) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    memoize,\n    size\n  } = opts;\n  const memoized = memo.get(cache, key, opts);\n  if (memoized && memoize !== false) return getMemoizedStream(memoized);\n  const stream = new Pipeline();\n  index.find(cache, key).then(entry => {\n    if (!entry) throw new index.NotFoundError(cache, key);\n    stream.emit('metadata', entry.metadata);\n    stream.emit('integrity', entry.integrity);\n    stream.emit('size', entry.size);\n    stream.on('newListener', function (ev, cb) {\n      ev === 'metadata' && cb(entry.metadata);\n      ev === 'integrity' && cb(entry.integrity);\n      ev === 'size' && cb(entry.size);\n    });\n    const src = read.readStream(cache, entry.integrity, { ...opts,\n      size: typeof size !== 'number' ? entry.size : size\n    });\n\n    if (memoize) {\n      const memoStream = new Collect.PassThrough();\n      memoStream.on('collect', data => memo.put(cache, entry, data, opts));\n      stream.unshift(memoStream);\n    }\n\n    stream.unshift(src);\n  }).catch(err => stream.emit('error', err));\n  return stream;\n}\n\nmodule.exports.stream = getStream;\n\nfunction getStreamDigest(cache, integrity) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    memoize\n  } = opts;\n  const memoized = memo.get.byDigest(cache, integrity, opts);\n\n  if (memoized && memoize !== false) {\n    const stream = new Minipass();\n    stream.end(memoized);\n    return stream;\n  } else {\n    const stream = read.readStream(cache, integrity, opts);\n    if (!memoize) return stream;\n    const memoStream = new Collect.PassThrough();\n    memoStream.on('collect', data => memo.put.byDigest(cache, integrity, data, opts));\n    return new Pipeline(stream, memoStream);\n  }\n}\n\nmodule.exports.stream.byDigest = getStreamDigest;\n\nfunction info(cache, key) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    memoize\n  } = opts;\n  const memoized = memo.get(cache, key, opts);\n  if (memoized && memoize !== false) return Promise.resolve(memoized.entry);else return index.find(cache, key);\n}\n\nmodule.exports.info = info;\n\nfunction copy(cache, key, dest) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (read.copy) {\n    return index.find(cache, key, opts).then(entry => {\n      if (!entry) throw new index.NotFoundError(cache, key);\n      return read.copy(cache, entry.integrity, dest, opts).then(() => {\n        return {\n          metadata: entry.metadata,\n          size: entry.size,\n          integrity: entry.integrity\n        };\n      });\n    });\n  }\n\n  return getData(cache, key, opts).then(res => {\n    return writeFile(dest, res.data).then(() => {\n      return {\n        metadata: res.metadata,\n        size: res.size,\n        integrity: res.integrity\n      };\n    });\n  });\n}\n\nmodule.exports.copy = copy;\n\nfunction copyByDigest(cache, key, dest) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (read.copy) return read.copy(cache, key, dest, opts).then(() => key);\n  return getDataByDigest(cache, key, opts).then(res => {\n    return writeFile(dest, res).then(() => key);\n  });\n}\n\nmodule.exports.copy.byDigest = copyByDigest;\nmodule.exports.hasContent = read.hasContent;","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/cacache/get.js"],"names":["Collect","require","Minipass","Pipeline","fs","util","index","memo","read","writeFile","promisify","getData","cache","key","opts","integrity","memoize","size","memoized","get","Promise","resolve","metadata","entry","data","find","then","NotFoundError","put","module","exports","getDataByDigest","byDigest","res","getDataSync","sync","getDataByDigestSync","digest","getMemoizedStream","stream","on","ev","cb","end","getStream","emit","src","readStream","memoStream","PassThrough","unshift","catch","err","getStreamDigest","info","copy","dest","copyByDigest","hasContent"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Collect = require('minipass-collect')\nconst Minipass = require('minipass')\nconst Pipeline = require('minipass-pipeline')\nconst fs = require('fs')\nconst util = require('util')\n\nconst index = require('./lib/entry-index')\nconst memo = require('./lib/memoization')\nconst read = require('./lib/content/read')\n\nconst writeFile = util.promisify(fs.writeFile)\n\nfunction getData (cache, key, opts = {}) {\n  const { integrity, memoize, size } = opts\n  const memoized = memo.get(cache, key, opts)\n  if (memoized && memoize !== false) {\n    return Promise.resolve({\n      metadata: memoized.entry.metadata,\n      data: memoized.data,\n      integrity: memoized.entry.integrity,\n      size: memoized.entry.size,\n    })\n  }\n\n  return index.find(cache, key, opts).then((entry) => {\n    if (!entry)\n      throw new index.NotFoundError(cache, key)\n\n    return read(cache, entry.integrity, { integrity, size }).then((data) => {\n      if (memoize)\n        memo.put(cache, entry, data, opts)\n\n      return {\n        data,\n        metadata: entry.metadata,\n        size: entry.size,\n        integrity: entry.integrity,\n      }\n    })\n  })\n}\nmodule.exports = getData\n\nfunction getDataByDigest (cache, key, opts = {}) {\n  const { integrity, memoize, size } = opts\n  const memoized = memo.get.byDigest(cache, key, opts)\n  if (memoized && memoize !== false)\n    return Promise.resolve(memoized)\n\n  return read(cache, key, { integrity, size }).then((res) => {\n    if (memoize)\n      memo.put.byDigest(cache, key, res, opts)\n    return res\n  })\n}\nmodule.exports.byDigest = getDataByDigest\n\nfunction getDataSync (cache, key, opts = {}) {\n  const { integrity, memoize, size } = opts\n  const memoized = memo.get(cache, key, opts)\n\n  if (memoized && memoize !== false) {\n    return {\n      metadata: memoized.entry.metadata,\n      data: memoized.data,\n      integrity: memoized.entry.integrity,\n      size: memoized.entry.size,\n    }\n  }\n  const entry = index.find.sync(cache, key, opts)\n  if (!entry)\n    throw new index.NotFoundError(cache, key)\n  const data = read.sync(cache, entry.integrity, {\n    integrity: integrity,\n    size: size,\n  })\n  const res = {\n    metadata: entry.metadata,\n    data: data,\n    size: entry.size,\n    integrity: entry.integrity,\n  }\n  if (memoize)\n    memo.put(cache, entry, res.data, opts)\n\n  return res\n}\n\nmodule.exports.sync = getDataSync\n\nfunction getDataByDigestSync (cache, digest, opts = {}) {\n  const { integrity, memoize, size } = opts\n  const memoized = memo.get.byDigest(cache, digest, opts)\n\n  if (memoized && memoize !== false)\n    return memoized\n\n  const res = read.sync(cache, digest, {\n    integrity: integrity,\n    size: size,\n  })\n  if (memoize)\n    memo.put.byDigest(cache, digest, res, opts)\n\n  return res\n}\nmodule.exports.sync.byDigest = getDataByDigestSync\n\nconst getMemoizedStream = (memoized) => {\n  const stream = new Minipass()\n  stream.on('newListener', function (ev, cb) {\n    ev === 'metadata' && cb(memoized.entry.metadata)\n    ev === 'integrity' && cb(memoized.entry.integrity)\n    ev === 'size' && cb(memoized.entry.size)\n  })\n  stream.end(memoized.data)\n  return stream\n}\n\nfunction getStream (cache, key, opts = {}) {\n  const { memoize, size } = opts\n  const memoized = memo.get(cache, key, opts)\n  if (memoized && memoize !== false)\n    return getMemoizedStream(memoized)\n\n  const stream = new Pipeline()\n  index\n    .find(cache, key)\n    .then((entry) => {\n      if (!entry)\n        throw new index.NotFoundError(cache, key)\n\n      stream.emit('metadata', entry.metadata)\n      stream.emit('integrity', entry.integrity)\n      stream.emit('size', entry.size)\n      stream.on('newListener', function (ev, cb) {\n        ev === 'metadata' && cb(entry.metadata)\n        ev === 'integrity' && cb(entry.integrity)\n        ev === 'size' && cb(entry.size)\n      })\n\n      const src = read.readStream(\n        cache,\n        entry.integrity,\n        { ...opts, size: typeof size !== 'number' ? entry.size : size }\n      )\n\n      if (memoize) {\n        const memoStream = new Collect.PassThrough()\n        memoStream.on('collect', data => memo.put(cache, entry, data, opts))\n        stream.unshift(memoStream)\n      }\n      stream.unshift(src)\n    })\n    .catch((err) => stream.emit('error', err))\n\n  return stream\n}\n\nmodule.exports.stream = getStream\n\nfunction getStreamDigest (cache, integrity, opts = {}) {\n  const { memoize } = opts\n  const memoized = memo.get.byDigest(cache, integrity, opts)\n  if (memoized && memoize !== false) {\n    const stream = new Minipass()\n    stream.end(memoized)\n    return stream\n  } else {\n    const stream = read.readStream(cache, integrity, opts)\n    if (!memoize)\n      return stream\n\n    const memoStream = new Collect.PassThrough()\n    memoStream.on('collect', data => memo.put.byDigest(\n      cache,\n      integrity,\n      data,\n      opts\n    ))\n    return new Pipeline(stream, memoStream)\n  }\n}\n\nmodule.exports.stream.byDigest = getStreamDigest\n\nfunction info (cache, key, opts = {}) {\n  const { memoize } = opts\n  const memoized = memo.get(cache, key, opts)\n  if (memoized && memoize !== false)\n    return Promise.resolve(memoized.entry)\n  else\n    return index.find(cache, key)\n}\nmodule.exports.info = info\n\nfunction copy (cache, key, dest, opts = {}) {\n  if (read.copy) {\n    return index.find(cache, key, opts).then((entry) => {\n      if (!entry)\n        throw new index.NotFoundError(cache, key)\n      return read.copy(cache, entry.integrity, dest, opts)\n        .then(() => {\n          return {\n            metadata: entry.metadata,\n            size: entry.size,\n            integrity: entry.integrity,\n          }\n        })\n    })\n  }\n\n  return getData(cache, key, opts).then((res) => {\n    return writeFile(dest, res.data).then(() => {\n      return {\n        metadata: res.metadata,\n        size: res.size,\n        integrity: res.integrity,\n      }\n    })\n  })\n}\nmodule.exports.copy = copy\n\nfunction copyByDigest (cache, key, dest, opts = {}) {\n  if (read.copy)\n    return read.copy(cache, key, dest, opts).then(() => key)\n\n  return getDataByDigest(cache, key, opts).then((res) => {\n    return writeFile(dest, res).then(() => key)\n  })\n}\nmodule.exports.copy.byDigest = copyByDigest\n\nmodule.exports.hasContent = read.hasContent\n"]},"metadata":{},"sourceType":"script"}