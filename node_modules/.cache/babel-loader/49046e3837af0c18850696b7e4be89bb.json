{"ast":null,"code":"const {\n  promisify\n} = require('util');\n\nconst fs = require('fs');\n\nconst readFile = promisify(fs.readFile);\nconst lstat = promisify(fs.lstat);\nconst readdir = promisify(fs.readdir);\n\nconst parse = require('json-parse-even-better-errors');\n\nconst {\n  resolve,\n  dirname,\n  join,\n  relative\n} = require('path');\n\nconst rpj = path => readFile(path, 'utf8').then(data => readBinDir(path, normalize(stripUnderscores(parse(data))))).catch(er => {\n  er.path = path;\n  throw er;\n});\n\nconst normalizePackageBin = require('npm-normalize-package-bin'); // load the directories.bin folder as a 'bin' object\n\n\nconst readBinDir = async (path, data) => {\n  if (data.bin) return data;\n  const m = data.directories && data.directories.bin;\n  if (!m || typeof m !== 'string') return data; // cut off any monkey business, like setting directories.bin\n  // to ../../../etc/passwd or /etc/passwd or something like that.\n\n  const root = dirname(path);\n  const dir = join('.', join('/', m));\n  data.bin = await walkBinDir(root, dir, {});\n  return data;\n};\n\nconst walkBinDir = async (root, dir, obj) => {\n  const entries = await readdir(resolve(root, dir)).catch(() => []);\n\n  for (const entry of entries) {\n    if (entry.charAt(0) === '.') continue;\n    const f = resolve(root, dir, entry); // ignore stat errors, weird file types, symlinks, etc.\n\n    const st = await lstat(f).catch(() => null);\n    if (!st) continue;else if (st.isFile()) obj[entry] = relative(root, f);else if (st.isDirectory()) await walkBinDir(root, join(dir, entry), obj);\n  }\n\n  return obj;\n}; // do not preserve _fields set in files, they are sus\n\n\nconst stripUnderscores = data => {\n  for (const key of Object.keys(data).filter(k => /^_/.test(k))) delete data[key];\n\n  return data;\n};\n\nconst normalize = data => {\n  add_id(data);\n  fixBundled(data);\n  pruneRepeatedOptionals(data);\n  fixScripts(data);\n  fixFunding(data);\n  normalizePackageBin(data);\n  return data;\n};\n\nrpj.normalize = normalize;\n\nconst add_id = data => {\n  if (data.name && data.version) data._id = `${data.name}@${data.version}`;\n  return data;\n}; // it was once common practice to list deps both in optionalDependencies\n// and in dependencies, to support npm versions that did not know abbout\n// optionalDependencies.  This is no longer a relevant need, so duplicating\n// the deps in two places is unnecessary and excessive.\n\n\nconst pruneRepeatedOptionals = data => {\n  const od = data.optionalDependencies;\n  const dd = data.dependencies || {};\n\n  if (od && typeof od === 'object') {\n    for (const name of Object.keys(od)) {\n      delete dd[name];\n    }\n  }\n\n  if (Object.keys(dd).length === 0) delete data.dependencies;\n  return data;\n};\n\nconst fixBundled = data => {\n  const bdd = data.bundledDependencies;\n  const bd = data.bundleDependencies === undefined ? bdd : data.bundleDependencies;\n  if (bd === false) data.bundleDependencies = [];else if (bd === true) data.bundleDependencies = Object.keys(data.dependencies || {});else if (bd && typeof bd === 'object') {\n    if (!Array.isArray(bd)) data.bundleDependencies = Object.keys(bd);else data.bundleDependencies = bd;\n  } else delete data.bundleDependencies;\n  delete data.bundledDependencies;\n  return data;\n};\n\nconst fixScripts = data => {\n  if (!data.scripts || typeof data.scripts !== 'object') {\n    delete data.scripts;\n    return data;\n  }\n\n  for (const [name, script] of Object.entries(data.scripts)) {\n    if (typeof script !== 'string') delete data.scripts[name];\n  }\n\n  return data;\n};\n\nconst fixFunding = data => {\n  if (data.funding && typeof data.funding === 'string') data.funding = {\n    url: data.funding\n  };\n  return data;\n};\n\nmodule.exports = rpj;","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/read-package-json-fast/index.js"],"names":["promisify","require","fs","readFile","lstat","readdir","parse","resolve","dirname","join","relative","rpj","path","then","data","readBinDir","normalize","stripUnderscores","catch","er","normalizePackageBin","bin","m","directories","root","dir","walkBinDir","obj","entries","entry","charAt","f","st","isFile","isDirectory","key","Object","keys","filter","k","test","add_id","fixBundled","pruneRepeatedOptionals","fixScripts","fixFunding","name","version","_id","od","optionalDependencies","dd","dependencies","length","bdd","bundledDependencies","bd","bundleDependencies","undefined","Array","isArray","scripts","script","funding","url","module","exports"],"mappings":"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","sourcesContent":["const {promisify} = require('util')\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\nconst lstat = promisify(fs.lstat)\nconst readdir = promisify(fs.readdir)\nconst parse = require('json-parse-even-better-errors')\n\nconst { resolve, dirname, join, relative } = require('path')\n\nconst rpj = path => readFile(path, 'utf8')\n  .then(data => readBinDir(path, normalize(stripUnderscores(parse(data)))))\n  .catch(er => {\n    er.path = path\n    throw er\n  })\n\nconst normalizePackageBin = require('npm-normalize-package-bin')\n\n// load the directories.bin folder as a 'bin' object\nconst readBinDir = async (path, data) => {\n  if (data.bin)\n    return data\n\n  const m = data.directories && data.directories.bin\n  if (!m || typeof m !== 'string')\n    return data\n\n  // cut off any monkey business, like setting directories.bin\n  // to ../../../etc/passwd or /etc/passwd or something like that.\n  const root = dirname(path)\n  const dir = join('.', join('/', m))\n  data.bin = await walkBinDir(root, dir, {})\n  return data\n}\n\nconst walkBinDir = async (root, dir, obj) => {\n  const entries = await readdir(resolve(root, dir)).catch(() => [])\n  for (const entry of entries) {\n    if (entry.charAt(0) === '.')\n      continue\n    const f = resolve(root, dir, entry)\n    // ignore stat errors, weird file types, symlinks, etc.\n    const st = await lstat(f).catch(() => null)\n    if (!st)\n      continue\n    else if (st.isFile())\n      obj[entry] = relative(root, f)\n    else if (st.isDirectory())\n      await walkBinDir(root, join(dir, entry), obj)\n  }\n  return obj\n}\n\n// do not preserve _fields set in files, they are sus\nconst stripUnderscores = data => {\n  for (const key of Object.keys(data).filter(k => /^_/.test(k)))\n    delete data[key]\n  return data\n}\n\nconst normalize = data => {\n  add_id(data)\n  fixBundled(data)\n  pruneRepeatedOptionals(data)\n  fixScripts(data)\n  fixFunding(data)\n  normalizePackageBin(data)\n  return data\n}\n\nrpj.normalize = normalize\n\nconst add_id = data => {\n  if (data.name && data.version)\n    data._id = `${data.name}@${data.version}`\n  return data\n}\n\n// it was once common practice to list deps both in optionalDependencies\n// and in dependencies, to support npm versions that did not know abbout\n// optionalDependencies.  This is no longer a relevant need, so duplicating\n// the deps in two places is unnecessary and excessive.\nconst pruneRepeatedOptionals = data => {\n  const od = data.optionalDependencies\n  const dd = data.dependencies || {}\n  if (od && typeof od === 'object') {\n    for (const name of Object.keys(od)) {\n      delete dd[name]\n    }\n  }\n  if (Object.keys(dd).length === 0)\n    delete data.dependencies\n  return data\n}\n\nconst fixBundled = data => {\n  const bdd = data.bundledDependencies\n  const bd = data.bundleDependencies === undefined ? bdd\n    : data.bundleDependencies\n\n  if (bd === false)\n    data.bundleDependencies = []\n  else if (bd === true)\n    data.bundleDependencies = Object.keys(data.dependencies || {})\n  else if (bd && typeof bd === 'object') {\n    if (!Array.isArray(bd))\n      data.bundleDependencies = Object.keys(bd)\n    else\n      data.bundleDependencies = bd\n  } else\n    delete data.bundleDependencies\n\n  delete data.bundledDependencies\n  return data\n}\n\nconst fixScripts = data => {\n  if (!data.scripts || typeof data.scripts !== 'object') {\n    delete data.scripts\n    return data\n  }\n\n  for (const [name, script] of Object.entries(data.scripts)) {\n    if (typeof script !== 'string')\n      delete data.scripts[name]\n  }\n  return data\n}\n\nconst fixFunding = data => {\n  if (data.funding && typeof data.funding === 'string')\n    data.funding = { url: data.funding }\n  return data\n}\n\nmodule.exports = rpj\n"]},"metadata":{},"sourceType":"script"}