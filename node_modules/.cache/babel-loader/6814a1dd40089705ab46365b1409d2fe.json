{"ast":null,"code":"// The goal here is to minimize both git workload and\n// the number of refs we download over the network.\n//\n// Every method ends up with the checked out working dir\n// at the specified ref, and resolves with the git sha.\n// Only certain whitelisted hosts get shallow cloning.\n// Many hosts (including GHE) don't always support it.\n// A failed shallow fetch takes a LOT longer than a full\n// fetch in most cases, so we skip it entirely.\n// Set opts.gitShallow = true/false to force this behavior\n// one way or the other.\nconst shallowHosts = new Set(['github.com', 'gist.github.com', 'gitlab.com', 'bitbucket.com', 'bitbucket.org']); // we have to use url.parse until we add the same shim that hosted-git-info has\n// to handle scp:// urls\n\nconst {\n  parse\n} = require('url'); // eslint-disable-line node/no-deprecated-api\n\n\nconst {\n  basename,\n  resolve\n} = require('path');\n\nconst revs = require('./revs.js');\n\nconst spawn = require('./spawn.js');\n\nconst {\n  isWindows\n} = require('./utils.js');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst fs = require('fs');\n\nconst mkdirp = require('mkdirp');\n\nmodule.exports = function (repo) {\n  let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'HEAD';\n  let target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return revs(repo, opts).then(revs => clone(repo, revs, ref, resolveRef(revs, ref, opts), target || defaultTarget(repo, opts.cwd), opts));\n};\n\nconst maybeShallow = (repo, opts) => {\n  if (opts.gitShallow === false || opts.gitShallow) {\n    return opts.gitShallow;\n  }\n\n  return shallowHosts.has(parse(repo).host);\n};\n\nconst defaultTarget = function (repo) {\n  let cwd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.cwd();\n  return resolve(cwd, basename(repo.replace(/[/\\\\]?\\.git$/, '')));\n};\n\nconst clone = (repo, revs, ref, revDoc, target, opts) => {\n  if (!revDoc) {\n    return unresolved(repo, ref, target, opts);\n  }\n\n  if (revDoc.sha === revs.refs.HEAD.sha) {\n    return plain(repo, revDoc, target, opts);\n  }\n\n  if (revDoc.type === 'tag' || revDoc.type === 'branch') {\n    return branch(repo, revDoc, target, opts);\n  }\n\n  return other(repo, revDoc, target, opts);\n};\n\nconst resolveRef = (revs, ref, opts) => {\n  const {\n    spec = {}\n  } = opts;\n  ref = spec.gitCommittish || ref;\n  /* istanbul ignore next - will fail anyway, can't pull */\n\n  if (!revs) {\n    return null;\n  }\n\n  if (spec.gitRange) {\n    return pickManifest(revs, spec.gitRange, opts);\n  }\n\n  if (!ref) {\n    return revs.refs.HEAD;\n  }\n\n  if (revs.refs[ref]) {\n    return revs.refs[ref];\n  }\n\n  if (revs.shas[ref]) {\n    return revs.refs[revs.shas[ref][0]];\n  }\n\n  return null;\n}; // pull request or some other kind of advertised ref\n\n\nconst other = (repo, revDoc, target, opts) => {\n  const shallow = maybeShallow(repo, opts);\n  const fetchOrigin = ['fetch', 'origin', revDoc.rawRef].concat(shallow ? ['--depth=1'] : []);\n\n  const git = args => spawn(args, { ...opts,\n    cwd: target\n  });\n\n  return mkdirp(target).then(() => git(['init'])).then(() => isWindows(opts) ? git(['config', '--local', '--add', 'core.longpaths', 'true']) : null).then(() => git(['remote', 'add', 'origin', repo])).then(() => git(fetchOrigin)).then(() => git(['checkout', revDoc.sha])).then(() => updateSubmodules(target, opts)).then(() => revDoc.sha);\n}; // tag or branches.  use -b\n\n\nconst branch = (repo, revDoc, target, opts) => {\n  const args = ['clone', '-b', revDoc.ref, repo, target, '--recurse-submodules'];\n\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1');\n  }\n\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true');\n  }\n\n  return spawn(args, opts).then(() => revDoc.sha);\n}; // just the head.  clone it\n\n\nconst plain = (repo, revDoc, target, opts) => {\n  const args = ['clone', repo, target, '--recurse-submodules'];\n\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1');\n  }\n\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true');\n  }\n\n  return spawn(args, opts).then(() => revDoc.sha);\n};\n\nconst updateSubmodules = (target, opts) => new Promise(resolve => fs.stat(target + '/.gitmodules', er => {\n  if (er) {\n    return resolve(null);\n  }\n\n  return resolve(spawn(['submodule', 'update', '-q', '--init', '--recursive'], { ...opts,\n    cwd: target\n  }));\n}));\n\nconst unresolved = (repo, ref, target, opts) => {\n  // can't do this one shallowly, because the ref isn't advertised\n  // but we can avoid checking out the working dir twice, at least\n  const lp = isWindows(opts) ? ['--config', 'core.longpaths=true'] : [];\n  const cloneArgs = ['clone', '--mirror', '-q', repo, target + '/.git'];\n\n  const git = args => spawn(args, { ...opts,\n    cwd: target\n  });\n\n  return mkdirp(target).then(() => git(cloneArgs.concat(lp))).then(() => git(['init'])).then(() => git(['checkout', ref])).then(() => updateSubmodules(target, opts)).then(() => git(['rev-parse', '--revs-only', 'HEAD'])).then(_ref => {\n    let {\n      stdout\n    } = _ref;\n    return stdout.trim();\n  });\n};","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/@npmcli/git/lib/clone.js"],"names":["shallowHosts","Set","parse","require","basename","resolve","revs","spawn","isWindows","pickManifest","fs","mkdirp","module","exports","repo","ref","target","opts","then","clone","resolveRef","defaultTarget","cwd","maybeShallow","gitShallow","has","host","process","replace","revDoc","unresolved","sha","refs","HEAD","plain","type","branch","other","spec","gitCommittish","gitRange","shas","shallow","fetchOrigin","rawRef","concat","git","args","updateSubmodules","push","Promise","stat","er","lp","cloneArgs","stdout","trim"],"mappings":"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","sourcesContent":["// The goal here is to minimize both git workload and\n// the number of refs we download over the network.\n//\n// Every method ends up with the checked out working dir\n// at the specified ref, and resolves with the git sha.\n\n// Only certain whitelisted hosts get shallow cloning.\n// Many hosts (including GHE) don't always support it.\n// A failed shallow fetch takes a LOT longer than a full\n// fetch in most cases, so we skip it entirely.\n// Set opts.gitShallow = true/false to force this behavior\n// one way or the other.\nconst shallowHosts = new Set([\n  'github.com',\n  'gist.github.com',\n  'gitlab.com',\n  'bitbucket.com',\n  'bitbucket.org'\n])\n// we have to use url.parse until we add the same shim that hosted-git-info has\n// to handle scp:// urls\nconst { parse } = require('url') // eslint-disable-line node/no-deprecated-api\nconst { basename, resolve } = require('path')\n\nconst revs = require('./revs.js')\nconst spawn = require('./spawn.js')\nconst { isWindows } = require('./utils.js')\n\nconst pickManifest = require('npm-pick-manifest')\nconst fs = require('fs')\nconst mkdirp = require('mkdirp')\n\nmodule.exports = (repo, ref = 'HEAD', target = null, opts = {}) =>\n  revs(repo, opts).then(revs => clone(\n    repo,\n    revs,\n    ref,\n    resolveRef(revs, ref, opts),\n    target || defaultTarget(repo, opts.cwd),\n    opts\n  ))\n\nconst maybeShallow = (repo, opts) => {\n  if (opts.gitShallow === false || opts.gitShallow) {\n    return opts.gitShallow\n  }\n  return shallowHosts.has(parse(repo).host)\n}\n\nconst defaultTarget = (repo, /* istanbul ignore next */ cwd = process.cwd()) =>\n  resolve(cwd, basename(repo.replace(/[/\\\\]?\\.git$/, '')))\n\nconst clone = (repo, revs, ref, revDoc, target, opts) => {\n  if (!revDoc) {\n    return unresolved(repo, ref, target, opts)\n  }\n  if (revDoc.sha === revs.refs.HEAD.sha) {\n    return plain(repo, revDoc, target, opts)\n  }\n  if (revDoc.type === 'tag' || revDoc.type === 'branch') {\n    return branch(repo, revDoc, target, opts)\n  }\n  return other(repo, revDoc, target, opts)\n}\n\nconst resolveRef = (revs, ref, opts) => {\n  const { spec = {} } = opts\n  ref = spec.gitCommittish || ref\n  /* istanbul ignore next - will fail anyway, can't pull */\n  if (!revs) {\n    return null\n  }\n  if (spec.gitRange) {\n    return pickManifest(revs, spec.gitRange, opts)\n  }\n  if (!ref) {\n    return revs.refs.HEAD\n  }\n  if (revs.refs[ref]) {\n    return revs.refs[ref]\n  }\n  if (revs.shas[ref]) {\n    return revs.refs[revs.shas[ref][0]]\n  }\n  return null\n}\n\n// pull request or some other kind of advertised ref\nconst other = (repo, revDoc, target, opts) => {\n  const shallow = maybeShallow(repo, opts)\n\n  const fetchOrigin = ['fetch', 'origin', revDoc.rawRef]\n    .concat(shallow ? ['--depth=1'] : [])\n\n  const git = (args) => spawn(args, { ...opts, cwd: target })\n  return mkdirp(target)\n    .then(() => git(['init']))\n    .then(() => isWindows(opts)\n      ? git(['config', '--local', '--add', 'core.longpaths', 'true'])\n      : null)\n    .then(() => git(['remote', 'add', 'origin', repo]))\n    .then(() => git(fetchOrigin))\n    .then(() => git(['checkout', revDoc.sha]))\n    .then(() => updateSubmodules(target, opts))\n    .then(() => revDoc.sha)\n}\n\n// tag or branches.  use -b\nconst branch = (repo, revDoc, target, opts) => {\n  const args = [\n    'clone',\n    '-b',\n    revDoc.ref,\n    repo,\n    target,\n    '--recurse-submodules'\n  ]\n  if (maybeShallow(repo, opts)) { args.push('--depth=1') }\n  if (isWindows(opts)) { args.push('--config', 'core.longpaths=true') }\n  return spawn(args, opts).then(() => revDoc.sha)\n}\n\n// just the head.  clone it\nconst plain = (repo, revDoc, target, opts) => {\n  const args = [\n    'clone',\n    repo,\n    target,\n    '--recurse-submodules'\n  ]\n  if (maybeShallow(repo, opts)) { args.push('--depth=1') }\n  if (isWindows(opts)) { args.push('--config', 'core.longpaths=true') }\n  return spawn(args, opts).then(() => revDoc.sha)\n}\n\nconst updateSubmodules = (target, opts) => new Promise(resolve =>\n  fs.stat(target + '/.gitmodules', er => {\n    if (er) {\n      return resolve(null)\n    }\n    return resolve(spawn([\n      'submodule',\n      'update',\n      '-q',\n      '--init',\n      '--recursive'\n    ], { ...opts, cwd: target }))\n  }))\n\nconst unresolved = (repo, ref, target, opts) => {\n  // can't do this one shallowly, because the ref isn't advertised\n  // but we can avoid checking out the working dir twice, at least\n  const lp = isWindows(opts) ? ['--config', 'core.longpaths=true'] : []\n  const cloneArgs = ['clone', '--mirror', '-q', repo, target + '/.git']\n  const git = (args) => spawn(args, { ...opts, cwd: target })\n  return mkdirp(target)\n    .then(() => git(cloneArgs.concat(lp)))\n    .then(() => git(['init']))\n    .then(() => git(['checkout', ref]))\n    .then(() => updateSubmodules(target, opts))\n    .then(() => git(['rev-parse', '--revs-only', 'HEAD']))\n    .then(({ stdout }) => stdout.trim())\n}\n"]},"metadata":{},"sourceType":"script"}