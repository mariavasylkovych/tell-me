{"ast":null,"code":"'use strict';\n\nmodule.exports = validate;\n\nfunction isArguments(thingy) {\n  return thingy != null && typeof thingy === 'object' && thingy.hasOwnProperty('callee');\n}\n\nconst types = {\n  '*': {\n    label: 'any',\n    check: () => true\n  },\n  A: {\n    label: 'array',\n    check: _ => Array.isArray(_) || isArguments(_)\n  },\n  S: {\n    label: 'string',\n    check: _ => typeof _ === 'string'\n  },\n  N: {\n    label: 'number',\n    check: _ => typeof _ === 'number'\n  },\n  F: {\n    label: 'function',\n    check: _ => typeof _ === 'function'\n  },\n  O: {\n    label: 'object',\n    check: _ => typeof _ === 'object' && _ != null && !types.A.check(_) && !types.E.check(_)\n  },\n  B: {\n    label: 'boolean',\n    check: _ => typeof _ === 'boolean'\n  },\n  E: {\n    label: 'error',\n    check: _ => _ instanceof Error\n  },\n  Z: {\n    label: 'null',\n    check: _ => _ == null\n  }\n};\n\nfunction addSchema(schema, arity) {\n  const group = arity[schema.length] = arity[schema.length] || [];\n  if (group.indexOf(schema) === -1) group.push(schema);\n}\n\nfunction validate(rawSchemas, args) {\n  if (arguments.length !== 2) throw wrongNumberOfArgs(['SA'], arguments.length);\n  if (!rawSchemas) throw missingRequiredArg(0, 'rawSchemas');\n  if (!args) throw missingRequiredArg(1, 'args');\n  if (!types.S.check(rawSchemas)) throw invalidType(0, ['string'], rawSchemas);\n  if (!types.A.check(args)) throw invalidType(1, ['array'], args);\n  const schemas = rawSchemas.split('|');\n  const arity = {};\n  schemas.forEach(schema => {\n    for (let ii = 0; ii < schema.length; ++ii) {\n      const type = schema[ii];\n      if (!types[type]) throw unknownType(ii, type);\n    }\n\n    if (/E.*E/.test(schema)) throw moreThanOneError(schema);\n    addSchema(schema, arity);\n\n    if (/E/.test(schema)) {\n      addSchema(schema.replace(/E.*$/, 'E'), arity);\n      addSchema(schema.replace(/E/, 'Z'), arity);\n      if (schema.length === 1) addSchema('', arity);\n    }\n  });\n  let matching = arity[args.length];\n\n  if (!matching) {\n    throw wrongNumberOfArgs(Object.keys(arity), args.length);\n  }\n\n  for (let ii = 0; ii < args.length; ++ii) {\n    let newMatching = matching.filter(schema => {\n      const type = schema[ii];\n      const typeCheck = types[type].check;\n      return typeCheck(args[ii]);\n    });\n\n    if (!newMatching.length) {\n      const labels = matching.map(_ => types[_[ii]].label).filter(_ => _ != null);\n      throw invalidType(ii, labels, args[ii]);\n    }\n\n    matching = newMatching;\n  }\n}\n\nfunction missingRequiredArg(num) {\n  return newException('EMISSINGARG', 'Missing required argument #' + (num + 1));\n}\n\nfunction unknownType(num, type) {\n  return newException('EUNKNOWNTYPE', 'Unknown type ' + type + ' in argument #' + (num + 1));\n}\n\nfunction invalidType(num, expectedTypes, value) {\n  let valueType;\n  Object.keys(types).forEach(typeCode => {\n    if (types[typeCode].check(value)) valueType = types[typeCode].label;\n  });\n  return newException('EINVALIDTYPE', 'Argument #' + (num + 1) + ': Expected ' + englishList(expectedTypes) + ' but got ' + valueType);\n}\n\nfunction englishList(list) {\n  return list.join(', ').replace(/, ([^,]+)$/, ' or $1');\n}\n\nfunction wrongNumberOfArgs(expected, got) {\n  const english = englishList(expected);\n  const args = expected.every(ex => ex.length === 1) ? 'argument' : 'arguments';\n  return newException('EWRONGARGCOUNT', 'Expected ' + english + ' ' + args + ' but got ' + got);\n}\n\nfunction moreThanOneError(schema) {\n  return newException('ETOOMANYERRORTYPES', 'Only one error type per argument signature is allowed, more than one found in \"' + schema + '\"');\n}\n\nfunction newException(code, msg) {\n  const err = new Error(msg);\n  err.code = code;\n  /* istanbul ignore else */\n\n  if (Error.captureStackTrace) Error.captureStackTrace(err, validate);\n  return err;\n}","map":{"version":3,"sources":["/Users/admin/Documents/mystudy/react/tell-me-react/tell-me-react/node_modules/npm/node_modules/aproba/index.js"],"names":["module","exports","validate","isArguments","thingy","hasOwnProperty","types","label","check","A","_","Array","isArray","S","N","F","O","E","B","Error","Z","addSchema","schema","arity","group","length","indexOf","push","rawSchemas","args","arguments","wrongNumberOfArgs","missingRequiredArg","invalidType","schemas","split","forEach","ii","type","unknownType","test","moreThanOneError","replace","matching","Object","keys","newMatching","filter","typeCheck","labels","map","num","newException","expectedTypes","value","valueType","typeCode","englishList","list","join","expected","got","english","every","ex","code","msg","err","captureStackTrace"],"mappings":"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","sourcesContent":["'use strict'\nmodule.exports = validate\n\nfunction isArguments (thingy) {\n  return thingy != null && typeof thingy === 'object' && thingy.hasOwnProperty('callee')\n}\n\nconst types = {\n  '*': {label: 'any', check: () => true},\n  A: {label: 'array', check: _ => Array.isArray(_) || isArguments(_)},\n  S: {label: 'string', check: _ => typeof _ === 'string'},\n  N: {label: 'number', check: _ => typeof _ === 'number'},\n  F: {label: 'function', check: _ => typeof _ === 'function'},\n  O: {label: 'object', check: _ => typeof _ === 'object' && _ != null && !types.A.check(_) && !types.E.check(_)},\n  B: {label: 'boolean', check: _ => typeof _ === 'boolean'},\n  E: {label: 'error', check: _ => _ instanceof Error},\n  Z: {label: 'null', check: _ => _ == null}\n}\n\nfunction addSchema (schema, arity) {\n  const group = arity[schema.length] = arity[schema.length] || []\n  if (group.indexOf(schema) === -1) group.push(schema)\n}\n\nfunction validate (rawSchemas, args) {\n  if (arguments.length !== 2) throw wrongNumberOfArgs(['SA'], arguments.length)\n  if (!rawSchemas) throw missingRequiredArg(0, 'rawSchemas')\n  if (!args) throw missingRequiredArg(1, 'args')\n  if (!types.S.check(rawSchemas)) throw invalidType(0, ['string'], rawSchemas)\n  if (!types.A.check(args)) throw invalidType(1, ['array'], args)\n  const schemas = rawSchemas.split('|')\n  const arity = {}\n\n  schemas.forEach(schema => {\n    for (let ii = 0; ii < schema.length; ++ii) {\n      const type = schema[ii]\n      if (!types[type]) throw unknownType(ii, type)\n    }\n    if (/E.*E/.test(schema)) throw moreThanOneError(schema)\n    addSchema(schema, arity)\n    if (/E/.test(schema)) {\n      addSchema(schema.replace(/E.*$/, 'E'), arity)\n      addSchema(schema.replace(/E/, 'Z'), arity)\n      if (schema.length === 1) addSchema('', arity)\n    }\n  })\n  let matching = arity[args.length]\n  if (!matching) {\n    throw wrongNumberOfArgs(Object.keys(arity), args.length)\n  }\n  for (let ii = 0; ii < args.length; ++ii) {\n    let newMatching = matching.filter(schema => {\n      const type = schema[ii]\n      const typeCheck = types[type].check\n      return typeCheck(args[ii])\n    })\n    if (!newMatching.length) {\n      const labels = matching.map(_ => types[_[ii]].label).filter(_ => _ != null)\n      throw invalidType(ii, labels, args[ii])\n    }\n    matching = newMatching\n  }\n}\n\nfunction missingRequiredArg (num) {\n  return newException('EMISSINGARG', 'Missing required argument #' + (num + 1))\n}\n\nfunction unknownType (num, type) {\n  return newException('EUNKNOWNTYPE', 'Unknown type ' + type + ' in argument #' + (num + 1))\n}\n\nfunction invalidType (num, expectedTypes, value) {\n  let valueType\n  Object.keys(types).forEach(typeCode => {\n    if (types[typeCode].check(value)) valueType = types[typeCode].label\n  })\n  return newException('EINVALIDTYPE', 'Argument #' + (num + 1) + ': Expected ' +\n    englishList(expectedTypes) + ' but got ' + valueType)\n}\n\nfunction englishList (list) {\n  return list.join(', ').replace(/, ([^,]+)$/, ' or $1')\n}\n\nfunction wrongNumberOfArgs (expected, got) {\n  const english = englishList(expected)\n  const args = expected.every(ex => ex.length === 1)\n    ? 'argument'\n    : 'arguments'\n  return newException('EWRONGARGCOUNT', 'Expected ' + english + ' ' + args + ' but got ' + got)\n}\n\nfunction moreThanOneError (schema) {\n  return newException('ETOOMANYERRORTYPES',\n    'Only one error type per argument signature is allowed, more than one found in \"' + schema + '\"')\n}\n\nfunction newException (code, msg) {\n  const err = new Error(msg)\n  err.code = code\n  /* istanbul ignore else */\n  if (Error.captureStackTrace) Error.captureStackTrace(err, validate)\n  return err\n}\n"]},"metadata":{},"sourceType":"script"}